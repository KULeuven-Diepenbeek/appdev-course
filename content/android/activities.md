---
title: 1. Life Cycle - Activities
---

## What's an activity?

> An activity is a **single, focused thing** that a user can do.

To put it simply, an activity is a window in your app. Each window should do one thing, such as:

- Let the user login
- Show a welcome screen
- Let the user pick something out of a list
- Show the user detail information of the picked item
- Let the user modify settings
- ...

![](/img/activities.png "Two example activities.")


(Images used on this page sourced from https://franklineduardojimenezgiraldo.gitbooks.io/android-studio/)

Since a single "activity"/action/screen/window/whatever-the-name is not going to cut it, multiple activities have to be developed and **wired together**. This is done using _wireframing_. A wireframe dictates the flow of the application. The above image represents a welcome screen, and a login screen. It might transition to the login screen after tapping or after three seconds. After pressing "Sign Up", it might transition again, to a master/detail screen. The resulting wireframe might look like this:

![](/img/wireframe.png "An example wireframe that defines relationships between activities.")

Since in many activities, components reappear, they get **re-used** by splitting an activity into _fragments_. We'll get to that in the [complex layouting - fragments](/android/fragments) part.

## Creating activities in Android Studio

Let's try to create **our first activity**: login screen. Which components can you identify in the above schematics?

1. A "Login" label or graphic
2. A username text field
3. A password text field
4. A login button
5. A "or" label
6. A "create account" button/anchor link

Right. These are simple enough. Create a new project, starting with an _Empty Activity_ under template _Phone and Tablet_. It'll create a single `MainActivity.kt` class with the following minimalistic code:

```kt
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}
```

The `activity_main.xml` will have a single `TextView` element with the label "Hello World!". Try to **bootstrap** the project before making any changes to ensure your compiler and emulator are set up correctly. 

The activity layout itself is described in XML. The root is currently `<androidx.constraintlayout.widget.ConstraintLayout/>"`. Remember JavaFX's `AnchorPane`, were you could drop components into using SceneBuilder? This is more or less the same, but the "Android way". There are of course multiple Layouts available. 

Browse through the [ConstraintLayout documentation](https://developer.android.com/reference/androidx/constraintlayout/widget/ConstraintLayout) and watch the [short introduction video](https://www.youtube.com/watch?v=XamMbnzI5vE) on how to build interfaces with it. It allows for multiple flexible ways to define constraints that dictate the position of the components: relative positioning, margins, centering, circular positioning, chaining, dimension constraining, and so forth. We'll minimize complexity by resorting to the GUI-editor embedded into Android Studio instead of writing too much UI-specific code. 

{{% notice note %}}
Fiddle with the layout editor to place the six needed components for the login screen.
{{% /notice %}}

Inspect and modify desired properties of components if needed in the right-hand pane of the Design Editor (especially the ID on the top-right):

![](/img/designproperties.jpg "Changing the text property of a TextView.")

Without specifying **constraints**, the components will be re-positioned to `(0, )` after publishing to your device. To add constraints, drag the circles to touching edges of the `ConstraintLayout`, or to other elements present in the activity. This "locks" the component, allowing it only to move by adhering to the constraints. After setting all constraints, try moving one of the components: others will move along with it due to the constraints. 

## Adding actions 

Once you've got a login button up and running, it would be nice if it actually did something when pressing it. The easiest way to do that is to use [Android View Binding](https://developer.android.com/topic/libraries/view-binding):

> **View binding** is a feature that allows you to more easily write code that interacts with views. Once view binding is enabled in a module, it generates a binding class for each XML layout file present in that module. An instance of a binding class contains direct references to all views that have an ID in the corresponding layout.

To enable, simply add the `buildFeature` in your `build.gradle.kts` file:

```
android {
    ...
    buildFeatures {
        viewBinding = true
    }
}
```

After refreshing, every XML layout file will be accompanied by a secretly _generated Java file_ that contains the items to access and attach events to. The name of the binding class is generated by converting the name of the XML file to Pascal case and adding the word "Binding" to the end. `activity_main.xml` will thus have an `ActivityMainBinding` class. 

In your "controller" (you do remember the Model-View-Controller pattern, right?) that extends from `AppCompatAcitivy`, add a `lateinit` binding field, and refer to it using `inflate()`. Then, we'll set the content view to that particular binding root. If that is done, we can add events:

```kt
class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)

        // warning, this is changed, it used to be R.main.id
        setContentView(binding.root)

        // just to prove things changed
        binding.btnLogin.setText("lol")        
    }
}
```

In JavaFX, this is a bit simpler:

```java
public class SomeController {
    @FXML
    private BUtton btnLogin;

    @FXML
    public void initialize() {
        btnLogin.setOnClick....
    }
}
```

Here, we can create fields and auto-wire them. In Android, you have to rely on the generated binding class where the fields are: less messy but one more step needed to take.

We react to events such as the `click` ("tap") event in the same way as you would do in JavaFX:

```kt
binding.btnLogin.setOnClickListener { view ->
    Snackbar.make(view, "Nice, clicked a button", Snackbar.LENGTH_LONG).setAction("Action", null).show()
}
```

`Snackbar` is a fast way to provide periodical feedback that automatically disappears. Ta-daa:

![](/img/loginbtn.jpg)

{{% notice note %}}
Retrieve the password value and check it with some hard-coded value. If not correct, show a warning message using a `Snackbar`. If the username is empty, also show a warning message.
{{% /notice %}}

## Adding a second Activity

What should happen once we're logged in successfully? Take another look at the first image on this page: a **welcome screen** would be nice. 

Create a second layout XML file by right-clicking on the `res` folder (or layout), select New -- Layout Resource File, and name it `activity_welcome`. You're given the option to change the root element, but another `ConstraintLayout` is fine, since we're now familiar with the basics of element placing in that particular layout. Go to the design editor and pull in a nice welcome text and a sample image that corresponds to the user's avatar. When you're done with that, create the corresponding controller class called `WelcomeActivity`. 

Next, we need a piece of code to change the activity to the new one, provided the password is correct. That's done using an **Intent**, of which we'll see more in the next chapter. An intent is a way to pass messages from one activity to another, but also to tell one activity it should transition to the other:

```kt
val intent = Intent(this, MyNewActivity::class.java)
startActivity(intent)
```

Note that `::class.java` is the Kotlin way to grab hold of the static `.class` instance of a class. Run your app and see if it works. Chances are you'll see it crash with the following message in the console:

```
E/AndroidRuntime: FATAL EXCEPTION: main
    Process: be.kuleuven.login, PID: 8457
    android.content.ActivityNotFoundException: Unable to find explicit activity class {be.kuleuven.login/be.kuleuven.login.WelcomeActivity}; have you declared this activity in your AndroidManifest.xml?
        at android.app.Instrumentation.checkStartActivityResult(Instrumentation.java:2065)
        at android.app.Instrumentation.execStartActivity(Instrumentation.java:1727)
        at android.app.Activity.startActivityForResult(Activity.java:5320)
```

Whoops. Each activity needs to be defined in the `AndroidManifest.xml` file where you can specify which one is the "main" that needs to be boostrapped as your application launches. Add an `<activity/>` tag there and try to guess the correct properties. Android Studio will auto-complete things for you. Make sure `exported` is set to `true`.

Try again and it should work!

{{% notice note %}}
A note on (text) sizes: in Common Attributes, changing the text size means selecting a unit in `sp`, not `px`. What's an `sp`? To be able to support **different pixel densities** of different screens, we do not rely on hard-coded pixels but let this be calculated. SP = _Scalable Pixels_ and is used for scaling text. Otherwise, use `dp`. DP = _Density-Independent Pixels_. See the [andorid multiscreen dev guide](https://developer.android.com/training/multiscreen/screendensities) for more information on how pixels are effectively calculated. Watch the video to get a better grasp of Android's _logical pixel densities_. **Never use `px`**! <br/>The same is true for graphic assets, but to avoid automatic scaling which usually ruins your PNGs, provide at least four different versions: one for each `dp` "bucket": MDPI, HDPI, XHDPI and XXHDPI. Again, see the documentation. 
{{% /notice %}}

To learn more about message passing, see [messaging: intents](/android/intents).
