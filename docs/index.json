[
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/",
	"title": "1. Android Essentials",
	"tags": [],
	"description": "",
	"content": " The Android Life Cycle: Activities Messaging between activities and apps: Intents Complex layouting: Fragments Typical (master/detail) layouts and their adapters: Views Data storage: File and Network access Embedded Hardware: Signals Security by design  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/lang/",
	"title": "2. Language &amp; Support Tools",
	"tags": [],
	"description": "",
	"content": " The Kotlin Programming language: essentials The Kotlin Programming language: advanced techniques Kotlin Examples Test Driven Development and mobile dev. Multiplatform mobile dev.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/extra/",
	"title": "3. Extra info",
	"tags": [],
	"description": "",
	"content": "Extra info  Installation guide Common errors FAQ Links and external tutorials Project information Need inspiration? A sample/demo project  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/extra/install/",
	"title": "1. Installation Guide",
	"tags": [],
	"description": "",
	"content": "1. Downloading Android Studio Go to developer.android.com/studio and download the latest stable release of the Android Studio IDE (green button). It comes with a JDK version to compile the necessary Java/Kotlin files and automatically downloads the correct Gradle version depending on your project file.\nBear in mind that the installation will download the required Google Android Development Kit (SDK), chipping away yet another gigabyte form your download limit.\nRequired IDE disk space: 1.5 GB Required SDK disk space: 3.1 GB Required Gradle Lib disk space (usually in ~/.gradle): 1.4 GB Required Cache disk space (usually in ~/.android): 2.3 GB\nTotaling to about 8.5 GB!! You\u0026rsquo;ve been warned.\nBut I\u0026rsquo;m on a Mac! If you are on a modern Mac with an M1 chipset (AMD64), download the latest preview version via the correct link in the archive page: https://developer.android.com/studio/archive Select the \u0026ldquo;Beta build\u0026rdquo; (called Arctic Fox), not the Canary build. Be mindful of the chipset architecture, otherwise the emulator will not work.\nThe program will be installed in /Applications/Android Studio Preview.app, and the Android SDK will be downloaded in ~/Library/Android. The emulator cache will live in ~/.android.\nBut I\u0026rsquo;m on Linux! A few notes for Linux users:\n Do not boot the IDE as root: emulators will be installed in in /root/android and cannot be found (error message will be something like that). If you get an error \u0026ldquo;permission denied /dev/kvm\u0026quot;: Add your use to the kvm group using the command useradd \u0026lt;username\u0026gt; kvm. See https://developer.android.com/studio/run/emulator-acceleration on how to install the right packages in your distribution. Note that as of June 2021, ia32-libs-multiarch does not exist anymore and is not needed.  2. Starting your first app Building When you\u0026rsquo;re finally done with the download and installation procedure, boot up the IDE again and you should be greeted with a \u0026ldquo;New Project\u0026rdquo; screen. Choose Basic Activity from the Phone and Tablet template, press Next and choose a name/location. Leave language on Kotlin and choose API 26 Android 8.0 (Oreo) for your Minimum SDK (should be selected by default).\nAfter pressing Finish, Android Studio will auto-download the correct Gradle version and dependencies.\n  Selecting a new project  Try to build the project (top right: hammer icon, or from Build menu, or using shortcuts). It will take a while the first time.\nDeploying Try to deploy the project. Your virtual machine will probably not be installed/downloaded yet. Go to the AVD manager (top right, open up the second combobox, or using menu Tools \u0026ndash; AVD Manager).\nChoosing the right API and target for your virtual device is extremely important. Be sure to match your CPU architecture (x64/arm64/\u0026hellip;). Be sure to try and match the API version with the API version in your build.gradle targetSdk/compileSdk/buildToolsVersion to avoid compatibility issues.\n The virtual device will likely have to be downloaded first, usually into ~/.android/avd, where the .ini config file of the emulator also resides.\n  Go to the AVD Manager in the build tool menu button bar  After correctly configuring your virtual device (the resolutions and device type do not matter that much right now), press the Play button again (Run app: CTRL+R). Hopefully, after a while, the emulator will do a cold boot (you should see the Android/Google logo and a home screen), and after that your compiled app will load up.\nFiddling Try to alter a few things here and there to see if recompiling/redeploying works. Try to make yourself familiar with the project structure while you\u0026rsquo;re at it:\n|- app |- build |- libs |- src |- main |- java |- com |- exampletest MainActivity.kt SomeFragment.kt |- res |- drawable someimage.jpg ic_laumcher_background.xml |- layout activity_main.xml content_main.xml somefragment.xml |- menu menu_main.xml |- navigation nav_graph.xml |- values colors.xml strings.xml ... |- mipmap ... AndroidManifest.xml |- test |- java |- com |- exampletest SomeTest.kt |- androidTest |- java |- com |- exampletest ExampleInstrumentedTest.kt build.gradle proguard-rules.pro |- build |- gradle build.gradle gradle.properties settings.gradle local.properties gradlew A few different things to remember:\nGradle The toplevel build.gradle file should not be modified\u0026mdash;changes usually happen in the build.gradle file in your app folder (In Android Studio: \u0026ldquo;Module\u0026rdquo;).\nThe wrapper properties file should point to Gradle 7.x for Android projects.\nFor more information on Gradle, see the Software Engineering Skills: Java Gradle Projects lessons. Remember that in case you create Kotlin DSL tyle Gradle projects, you should be on the lookout for build.gradle.kts - see Gradle Kotlin-style projects.\nCode In:\n src/main/java, as expected. src/test/java, as epected. These are your unit tests. src/androidTest/java\u0026mdash;woah, what\u0026rsquo;s this? These are android-instrumented specific tests that need to run on the device itself: usually UI-related tests. We\u0026rsquo;ll inspect thsese in the chapter on TDD.  Resources Android\u0026rsquo;s UIs are described instead of coded in accompanied .xml files. These live in app/src/res under subdirs layout, menu and navigation. See the Activities lesson to learn more about these files and their contents.\nFor now, go ahead and open up app/src/res/values/strings.xml. It should contain something like this:\n\u0026lt;resources\u0026gt; \u0026lt;string name=\u0026#34;app_name\u0026#34;\u0026gt;TestApp2\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;action_settings\u0026#34;\u0026gt;Settings\u0026lt;/string\u0026gt; \u0026lt;!-- Strings used for fragments for navigation --\u0026gt; \u0026lt;string name=\u0026#34;first_fragment_label\u0026#34;\u0026gt;First Fragment\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;second_fragment_label\u0026#34;\u0026gt;Second Fragment\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;next\u0026#34;\u0026gt;Next\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;previous\u0026#34;\u0026gt;Previous\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;hello_first_fragment\u0026#34;\u0026gt;Hello first fragment\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;hello_second_fragment\u0026#34;\u0026gt;Hello second fragment. Arg: %1$s\u0026lt;/string\u0026gt; \u0026lt;/resources\u0026gt; The resources can be accessed in the layout XMLs to put labels on buttons and re-use key/values. For example, a button can be defined as \u0026lt;Button ... android:text=\u0026quot;@string/next\u0026quot; .../\u0026gt;, referring to the label \u0026ldquo;Next\u0026rdquo; in the above XML.\nGo ahead and try to change the label of the example button to \u0026ldquo;Hello World!\u0026rdquo;. Go nuts.\nDouble-click on fragment_first.xml or activity_main.xml to see the UI editor. On the top right, you can see \u0026ldquo;Code | Split | Design\u0026rdquo;, to switch XML views, just like SceneBuilder in JavaFX. You do remember that from INF1, right?\nClick on Design and drag in a new ImageView from the Common palette. It will open a dialog called Pick a Resource. Press +, choose \u0026ldquo;Import Drawables\u0026rdquo;, ans select a random image file. Images are also described in XML and fairly complex: for each resolution a new one should be provided in case your app runs on a tablet/big screen/small screen/horizontal/vertical mode, etc. The name does not matter.\n  A nice test image for our test app.  Note that after adding the image, the following code was added in the XML of the fragment:\n\u0026lt;ImageView android:id=\u0026#34;@+id/imageView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:src=\u0026#34;@drawable/_ee2e58a037610e49f7165f1df0087e1\u0026#34; tools:layout_editor_absoluteX=\u0026#34;0dp\u0026#34; tools:layout_editor_absoluteY=\u0026#34;0dp\u0026#34; /\u0026gt; Redeploy your test app to verify if it works in your emulator.\nYay! Crackling fireworks! You\u0026rsquo;ve officially gained the right to proclaim It Works On My Machine.\nGetting to know the IDE Android Studio is part of JetBrains' IDEA development environment. That is, it behaves and functions exactly like its other products:\n CLion for cross-platform C/C++ development, used in the Software Design in C/C++ Course GoLand, the most complete Go-centric IDE IntelliJ IntelliJ, the well-respected Java-centered development environment, used in INF1/Software Engineering Skills  Shortcuts\nSince Android Studio is built on top of IntelliJ\u0026rsquo;s IDEA, the shortcut key keymaps are the same!\nHave a look at the IDEA Reference keymap card\nMore features\nConsult Meeting Android Studio at developer.android.com for a run-down on the User Interface and project structure guide of the IDE. This should be familiar to you, as you have used other JetBrains products in other courses in your engineering trajectory.\nTry to (re-)familiarize yourself with the tool by trying to:\n Quickly access a certain file/method/class Zooming in and out, and switching to presenter mode Auto-completing a code fragment Automatically generating a constructor and getters/setters Navigating to a test method Running unit tests and switching to the tests while navigating the production code Executing specific Gradle tasks Setting breakpoints and walking through these in debug mode \u0026hellip;  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/lang/kotlin/",
	"title": "1. Kotlin programming: Essentials",
	"tags": [],
	"description": "",
	"content": "Why in Kotlin, Yet Another Language? Good question! The answer is multi-faceted:\n1. Because Google Says So Google says you should Develop Android apps with Kotlin. It\u0026rsquo;s their recommended way of doing so. They state:\n Write better Android apps faster with Kotlin. Kotlin is a modern statically typed programming language used by over 60% of professional Android developers that helps boost productivity, developer satisfaction, and code safety.\n Among a slew of listed advantages, they have also created an Android Basics in Kotlin course, where the basics of the Kotlin language is the first hurdle to take.\nThanks to Google\u0026rsquo;s push for Kotlin, open source Android projects on GitHub, GitLab, and friends have boomed, massively switching from Java to Kotlin. It is still possible to write Java-like code and mix in a bit of Kotlin here and there: that is one of the powers of a language on top of the JVM. It would make no sense for us to teach you Android development without touching upon Kotlin, as reading source code of bigger projects would become hard since they\u0026rsquo;re littered with Kotlin-specific syntax.\nTry navigating your way through a few of the following popular open source repositories:\n https://github.com/ccomeaux/boardgamegeek4android \u0026mdash; a BoardGameGeek client for Android https://gitlab.com/AuroraOSS/AuroraStore \u0026mdash; A Google Playstore Client https://github.com/owncloud/android \u0026mdash; The ownCloud Android App https://github.com/mrcsxsiq/Kotlin-Pokedex \u0026mdash; Gotta Catch \u0026lsquo;em All! Pokémon!  Simply search for \u0026ldquo;kotlin\u0026rdquo; and \u0026ldquo;android\u0026rdquo; on GitHub and you\u0026rsquo;ll find yourself wading knee-deep into modern and highly-maintained app source code.\nMoreover, troubleshooting using Google/Stack Overflow usually nets you Kotlin code, as it\u0026rsquo;s become that common. Yet another point in favor for learning Android app development \u0026ldquo;the recommended way\u0026rdquo;. We promise it won\u0026rsquo;t hurt a bit. Maybe only sting. Just a little bit.\n2. Because Kotlin is Java 2.0 Writing Kotlin code on the JVM still means programming on the JVM\u0026mdash;the Java Virtual Machine. That is, in the end, you\u0026rsquo;ll still need a firm grasp of Java if things get awry. The ability to decompile .class files lets you take a peek at what the Kotlin compiler does for us. See advanced Kotlin aspects.\nSoftware developers are slowly integrating parts of Kotlin into existing Java architectures: Kotlin mingles well with existing Java-based solutions. The learning curve, therefore, is flattened: you can choose to gradually migrate towards the new functionalities instead of having to go all out with a big bang.\nHowever, since within this course you\u0026rsquo;ll be creating new projects, we\u0026rsquo;ll opt for an all-in Kotlin solution here. In other courses such as Software Engineering Skills, you can choose to do parts in Kotlin, or everything\u0026mdash;or nothing. We hope you\u0026rsquo;ve come to appreciate the beauty of this relatively new language by then.\n3. Because We Say So The software department of ACRO, the KU Leuven research group at Diepenbeek Campus, focuses on functional languages, of which Kotlin certainly fits the bill. Kotlin\u0026rsquo;s functional mechanics are nowhere near as complex as Prolog or Scala (it is a multi-purpose multi-paradigm language, not a pure functional one such as the aforementioned), and is familiar enough for students who are used to writing programs in Java. Thus, with relative little effort, a new (both for you and for the programming community) language can be learned.\n How does Kotlin fit into the JVM? It\u0026rsquo;s actually very simple: you should treat Kotlin as a separate language that compiles into the same byte code class files as traditional Java .class files. These can be packaged into a .jar like any other Java app, and run using the JVM, that won\u0026rsquo;t even know it started as Kotlin code:\n  Compiling java/kotlin files. src: Kotlin in Action book  The only block that stands out here is the Kotlin runtime that has to be packaged with the application, using the correct arguments when compiling command-line:\nkotlinc hello.kt -include-runtime -d hello.jar The -include-runtime check simply tells the Kotlin compiler to pack along Kotlin\u0026rsquo;s API. That is, utility functions such as print(), that serve as simple wrappers for System.out.println(), need to be packaged in the same jar. That is, the Kotlin \u0026ldquo;runtime\u0026rdquo; (nothing runtime about it) is just a dependency! The above schematic also reveals that interoperability between Java and Kotlin is very easy: they\u0026rsquo;re both (eventually) JVM-class files! So, calling Kotlin from Java or Java from Kotlin is easy as pie.\nThe Kotlin language can also be compiled natively using the LLVM compiler, or compile into JavaScript and run on Node. We will be focusing on Kotlin for the JVM in this course.\n Now you\u0026rsquo;re ready to get your hands dirty!\nA Crash Course in Kotlin Roughly based upon Google\u0026rsquo;s Introduction to Kotlin crash course.\nPlay with Kotlin to get to know the language before focusing on Android specifics. The best way to do this is creating simple Kotlin projects in Intellij (see Kotlin examples) or simply by browsing to https://play.kotlinlang.org/\n1. Variables As mentioned before, Kotlin has many functional aspects to it. For variable declaration, you can pre-set a value, declaring it will never change (it\u0026rsquo;s a constant), or just call it a \u0026ldquo;variable\u0026rdquo;.\n// in Kotlin, you can leave out the argument in main() if you don\u0026#39;t need it! fun main(args: Array\u0026lt;String\u0026gt;) { println(\u0026#34;Hi from Kotlin! the Main fun(ction) can be placed outside a class. Cool!\u0026#34;) var count1: Int = 10 count1++ var count2 := 10 count2++ val count3: Int = 10 count3++ // compile error  val count4 = 10 count4++ // compile error } public class MainClass { public static void main(Stringp[] args) { System.out.println(\u0026#34;Hi from... ugly old... Java? Great... \u0026#34;); var count1 = 10; // this works in JDK9+  count1++; int count2 = 10; count2++; final var count3 = 10; count3++; // compile error  final int count4 = 10; count4++; // compile error  } }  This works just like in JavaScript: let (used to be var) and const.\nvalues cannot be changed: they\u0026rsquo;re values. What else is new? No ;\u0026mdash;finally! Note Kotlin has built-in type inference: specifying := Int is not needed, the compiler knows this since you provide a whole number on the right-hand side of the equation sign.\nTry to use val as much as possible: make verything immutable, unless you absolutely have to use a mutable variable. This is good practice that promotes functional-style programming and prevents making mistakes with, among others, concurrency. Note that val person = Person() means you cannot assign another Person to the person variable, but you can still mutate the reference itself: person.age = 10\u0026mdash;unless the setter is private, that is.\nSpot the new syntax in the next section:\nfun main() { var name: String = null // does not compile  name = \u0026#34;Wouter\u0026#34; var nameGood: String? = null nameGood = \u0026#34;Wouter\u0026#34; // We can just as well use standard Java invocations.  System.out.println(\u0026#34;My name is \u0026#34; + nameGood.orEmpty()) // this is simply a Kotlin-wrapper.  println(\u0026#34;My name is \u0026#34; + nameGood?.toLowerCase()) // without if check: use ?.  if(nameGood != null) { println(\u0026#34;My name surely is \u0026#34; + nameGood.toLowerCase()) // with if check: no ? after dot  } } This is called null safety. To assign null, you explicitly have to use the question mark ? sign. orEmpty() returns an empty string if the value it holds is effectively null. This method, or using var?. to access properties, omits needlessly checking with if(...) statements, complicating your codebase, such as the last two statements.\nAll standard JDK API methods are still available to you. Remember that you are still working on a Java-specific Virtual Machine. Thus, System.out.println() is still valid (but can be shortened to println(), imported from package kotlin.io), although you have to omit the ; at the end of the statement. So, in essence, you already know how to create threads, access files, \u0026hellip;! This is also very important in Android development, as many system-level Android API methods are still Java.\n 2. Conditionals if() is still if(), including the else. What\u0026rsquo;s more interesting, however, is the possibility of replacing your if-else expressions with a when expression:\nval answerString = when { count == 42 -\u0026gt; \u0026#34;I have the answer.\u0026#34; count \u0026gt; 35 -\u0026gt; \u0026#34;The answer is close.\u0026#34; else -\u0026gt; \u0026#34;The answer eludes me.\u0026#34; } println(answerString) // awkward! Need some kind of wrapper private String cantAssignResultOfSwitchInAVar() { switch(count) { case 42: return \u0026#34;I have the answer.\u0026#34;; case 41: case 40: case 39: // wow, this is awkward! \u0026#34;\u0026gt; 35\u0026#34; is impossible in Java.  case 38: case 37: case 36: return \u0026#34;The answer is close.\u0026#34;; default: return \u0026#34;The answer eludes me.\u0026#34;; } return \u0026#34;\u0026#34;; // awkward. String answerString = cantAssignResultOfSwitchInAVar();  Note that in the example above, the expression seems to be missing. If when is used without brackets, Kotlin will check for Boolean values. when is very powerful in Kotlin, compared to switch in Java, that requires constants. You can when over any string/object instance/whatever:\nval color = Color(RED) when(color) { Color(GREEN) -\u0026gt; print(\u0026#34;its green\u0026#34;) Color(RED) -\u0026gt; print(\u0026#34;its red\u0026#34;) } Color color = new Color(RED); if(color.equals(new Color(GREEN))) { System.out.println(\u0026#34;its green\u0026#34;) } else if(color.equals(new Color(RED))) { System.out.println(\u0026#34;its red\u0026#34;) }  Kotlin uses equality checks behind the scenes, the only possible way to implement it in Java. Take a look at the Java implementation to uncover its details.\nNote that no ternary operator exists (val bla = d == 10 ? \u0026quot;jup\u0026quot; : \u0026quot;nah\u0026quot;), although that can be written in a single-line using Kotlin\u0026rsquo;s if:\nIn Kotlin, if and when constructs are expressions: they hold a value. In Java, they are statements that require code blocks. That means that both constructs can appear on the right-hand side of a variable assignment in one line. Don\u0026rsquo;t let the weird syntax scare you: var max = if(a \u0026gt; b) a else b. This makes the ternary operator redundant.\n 3. Classes and Functions Suppose we\u0026rsquo;d like to represent a pawn and its position. This is the (often painfully long) Java way to do it:\npublic class Pawn { private int x; private int y; public Pawn(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public int getY() { return y; } public void setX(int x) { this.x = x; } public void setY(int y) { this.y = y; } @Override public String toString() { return \u0026#34;(\u0026#34; + x + \u0026#34;,\u0026#34; + y + \u0026#34;)\u0026#34;; } } public class Main { public static void main(Stringp[] args) { Pawn p = new Pawn(1, 2); System.out.println(\u0026#34;p is at (\u0026#34; + p); } } While this is the Kotlin way:\nclass Pawn(theX: Int, theY: Int) { var x = theX private set var y = theY override fun toString(): String { return \u0026#34;($x,$y)\u0026#34; } } fun main() { val p = Pawn(1, 2) println(\u0026#34;p is at $p\u0026#34;) } That\u0026rsquo;s a lot shorter! What happened here?\n We create a class with a constructor\u0026mdash;on the same line. class Pawn { ... } would work just as well, but everything between () are constructor arguments. That means we can immediately use them in the assignments of the variables. Properties of the class are by default public! So p.y = 346 would be valid, but to countermeasure this, we set the setter to private. There are no \u0026ldquo;getter\u0026rdquo; and \u0026ldquo;setter\u0026rdquo; methods needed this way! You can still define them if you want using get() { below the variable name, as we did with the setter (that has no body, and thus stays the generated one). Remember to put the main() function outside any class. No separate (static) class needed for that. String interpolation exists in Kotlin. Within double quotes, you can access a variable using the $ prefix.  What is called a secondary constructor can still be made, using the more \u0026ldquo;classic\u0026rdquo; approach:\nclass Pawn { var x = 0 constructor(x: Int) { this.x = x } } However, this is to be avoided if only one constructor is sufficient.\nAs for defining functions, just fun name() {} suffices. Functions are public by default, contrary to Java\u0026rsquo;s package-access! Adding protected/private before fun prevents this.\n Want arguments? fun name(arg1: Type, arg2: Type). Want default arguments? fun name(arg1: Boolean = true) Want varargs? fun name(vararg bools: Boolean) Want a return type? fun name(): Type. (Note that void is Unit in Kotlin) Want to call the function? name(false) Want to name arguments while calling? name(arg1: false)  Single-line functions, called expression bodies, can be simplified from fun hi(): String { return \u0026quot;sup!\u0026quot; } to fun hi(): String = \u0026quot;sup!\u0026quot;. The body is specified after the = symbol, and you\u0026rsquo;ll see these functions often. The last statement will automatically be returned, so return can also be omitted. Expression bodies become very powerful when combined with when: fun hi(): String = when { ... }.  The official Kotlin coding conventions style guide recommends you use expression bodies when the body consists of a single expression (getters/setters come to mind).\n More information about unit-returning functions can be found here.\nSometimes, in Java, you need to quickly create a new subclass or an implementation of an interface, to be able to provide an event listener, for example. The typical syntax for that is very convoluted:\nwindow.addMouseListener(new MouseAdapter() { @Override public void mouseClicked(MouseEvent e) { System.out.println(\u0026#34;Good job, right on target!\u0026#34;); } @Override public void ... // ALL methods of the interface need to be provided! }) In Kotlin, an object is used, which is a \u0026ldquo;temporary class\u0026rdquo; that fits the bill:\nwindow.addMouseListener(object: MouseAdapter() { override fun mouseClicked(e: MouseEvent) { println(\u0026#34;Good job, right on target!\u0026#34;) } }) Note that the override keyword is required here. In Java, it\u0026rsquo;s just an annotation that adds to the documentation. In Kotlin, it\u0026rsquo;s part of the syntax.\nFor more information, see https://kotlinlang.org/docs/object-declarations.html#inheriting-anonymous-objects-from-supertypes\n4. Higher order functions Functions can also be variables. Functions can be created ad-hoc, and be disposed of when no longer needed, as part of the local stack. For instance:\nfun main() { var age = 30 var adder: (Int) -\u0026gt; Int = { x -\u0026gt; x + 1 } age = adder(age) println(\u0026#34;Hello, world!!! I\u0026#39;m currently $ageold\u0026#34;) } Here, adder is again declared using an expression body. Try to get used to it! Functions can be declared within functions within functions within \u0026hellip; Its scope closes the variables around it, meaning you can shield off variables created inside functions from the outside world, but not the other way around. age is visible inside adder, but x is not visible inside main.\nThe above code is easily replicated in JavaScript:\nfunction main() { var age = 30 var adder = function(x) { return x + 1 } age = adder(age) console.log(`Hello, world!!! I\u0026#39;m currently ${age}old`) } But not so easily done in Java, although later JDK versions also introduced (clumsy versions of) lambda\u0026rsquo;s.\nA few more things to remember:\n Inside expression bodies, return is missing, but the result of the last line is returned instead. If a return type is missing, kotlin.Unit is returned, corresponding with void in Java. There\u0026rsquo;s also a Nothing type to dictate a function will always return an exception, such as an assertion.  Functions can return functions or accept functions as arguments. This is handy when recycling logic that sorts, collects, or filters collections. Speaking of\u0026hellip;\n5. Arrays, Collections, Looping Kotlin\u0026rsquo;s Array\u0026lt;\u0026gt; generic class is the same as a [] in Java: it\u0026rsquo;s set in size. In Kotlin, arrays are simply classes: there\u0026rsquo;s no distinction between low-level arrays and high-level collections. However, most of the time, we\u0026rsquo;ll want to use Java\u0026rsquo;s ArrayList\u0026lt;\u0026gt; equivalent. Kotlin also leverages interfaces to hide the collection implementation. You will see MutableList\u0026lt;\u0026gt; often:\nclass Stuff(name: String) { val name = name override fun toString(): String { return name } } class Bag { val items: MutableList\u0026lt;Stuff\u0026gt; = mutableListOf(Stuff(\u0026#34;pen\u0026#34;), Stuff(\u0026#34;apple\u0026#34;)) }  Remember, as soon as you initialize an object and do not want to change it, use val instead of var. The list will grow and shrink in size as things get added and removed, but the reference to items, the list instance itself, will not change. That is, items = ArrayList\u0026lt;Stuff\u0026gt;(), which creates a new empty list, is something we don\u0026rsquo;t want to see somewhere in the code.\n Now that we have a bag of items, how do we print out each one? Add the following function to Bag:\nfun rummageThrough() { // option 1  for(item in items) { println(item) } // option 2  items.forEach { println(it) } // option 3, the closest thing to an ugly ol\u0026#39; for we have  for(x in 0..items.size) { print(items) } } The second function is the functional option where we pass in a closure that prints an item. The only argument is automatically available as it. This is how the forEach function is defined in _Collections.kt:\npublic inline fun \u0026lt;T\u0026gt; Iterable\u0026lt;T\u0026gt;.forEach(action: (T) -\u0026gt; Unit): Unit { for (element in this) action(element) } Hold on there! Where\u0026rsquo;s the argument action in our example? We say items.forEach { and not items.forEach(arg) {. This is a special case: if the last argument is a closure, the block that is attached to the function is the argument itself! This is yet another bit of syntactic sugar to ease the use of passing in functions as arguments.\nNot convinced? This piece of Java code:\n// wrongfully assumes \u0026#34;forEach\u0026#34; exists as a method on the collection public interface ForEachAction { void act(Item i); } items.forEach(new ForEachAction() { @Override public void act(Item i) { System.out.println(i); } }) Is the same as each of the following lines in Kotlin:\n// step 1: still too verbose items.forEach({ i: Item -\u0026gt; println(i) }) // step 2: a lambda expression can be moved out of the paranthesis if it\u0026#39;s the last argument items.forEach() { i: Item -\u0026gt; println(i) } // step 3: the empty parenthesis can also be removed if the lambda is the only argument items.forEach { i: Item -\u0026gt; println(i) } // step 4: parameter type inferred items.forEach { i -\u0026gt; println(i) s} // step 5: use the default parameter name \u0026#34;it\u0026#34; items.forEach { println(it) } The reason the above ForEachAction interface gets covered in a Kotlin lambda without having to refer to the method act at all is that it\u0026rsquo;s an interface with a single method: a functional interface or a Single Action Method (SAM) interface. The JDK and Android API are littered with these interfaces, and you already know many of those: java.lang.Runnable, java.util.Comparator, javax.event.EventhHandler, \u0026hellip; This means it\u0026rsquo;s easy to replace anonymous inner functions with Kotlin lambda\u0026rsquo;s when working with JDK/Android APIs. See the kotlin docs for more information.\nNext to forEach, Kotlin provides The Usual Suspects of functional loop tools, such as:\n .filter {} .reduce {} .sumOf {} .maxOf {} .removeIf {} .replaceAll {} \u0026hellip;  To initialize arrays/lists/whatever, Kotlin provides handy utility methods so that we don\u0026rsquo;t need to do silly plumbing as we\u0026rsquo;re used to do in Java. For instance, in Java, creating an ArrayList and adding stuff using new ArrayList\u0026lt;Bag\u0026gt;() { add(new Bag(\u0026quot;apple\u0026quot;); add... } is sometimes shortened using Arrays.asList(). In Kotlin, we simply rely on mutableListOf(Bag(\u0026quot;apple\u0026quot;)), arrayOf(...), arrayListOf(...), etc. There are no new collections introduced in the language: we simply leverage Java\u0026rsquo;s set. The only new things are the utility wrapper functions that come with the Kotlin runtime library.\nNow that you know the basics of Kotlin, you can start programming in the language and adhere to the structure and style of Java development as you are used to. The more you write Kotlin, the more you will gravitate towards functional-style programming. Advanced techniques shed more light on these. If you\u0026rsquo;re impatient, go ahead and start your first venture into the Android dungeons!Remember, if you\u0026rsquo;re stuck, open up the Kotlin docs and refresh your memory.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/activities/",
	"title": "1. Life Cycle - Activities",
	"tags": [],
	"description": "",
	"content": "What\u0026rsquo;s an activity?  An activity is a single, focused thing that a user can do.\n To put it simply, an activity is a window in your app. Each window should do one thing, such as:\n Let the user login Show a welcome screen Let the user pick something out of a list Show the user detail information of the picked item Let the user modify settings \u0026hellip;    Two example activities.  (Images used on this page sourced from https://franklineduardojimenezgiraldo.gitbooks.io/android-studio/)\nSince a single \u0026ldquo;activity\u0026rdquo;/action/screen/window/whatever-the-name is not going to cut it, multiple activities have to be developed and wired together. This is done using wireframing. A wireframe dictates the flow of the application. The above image represents a welcome screen, and a login screen. It might transition to the login screen after tapping or after three seconds. After pressing \u0026ldquo;Sign Up\u0026rdquo;, it might transition again, to a master/detail screen. The resulting wireframe might look like this:\n  An example wireframe that defines relationships between activities.  Since in many activities, components reappear, they get re-used by splitting an activity into fragments. We\u0026rsquo;ll get to that in the complex layouting - fragments part.\nCreating activities in Android Studio Let\u0026rsquo;s try to create our first activity: login screen. Which components can you identify in the above schematics?\n A \u0026ldquo;Login\u0026rdquo; label or graphic A username text field A password text field A login button A \u0026ldquo;or\u0026rdquo; label A \u0026ldquo;create account\u0026rdquo; button/anchor link  Right. These are simple enough. Create a new project, starting with an Empty Activity under template Phone and Tablet. It\u0026rsquo;ll create a single MainActivity.kt class with the following minimalistic code:\nclass MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } } The activity_main.xml will have a single TextView element with the label \u0026ldquo;Hello World!\u0026rdquo;. Try to bootstrap the project before making any changes to ensure your compiler and emulator are set up correctly.\nThe activity layout itself is described in XML. The root is currently \u0026lt;androidx.constraintlayout.widget.ConstraintLayout/\u0026gt;\u0026quot;. Remember JavaFX\u0026rsquo;s AnchorPane, were you could drop components into using SceneBuilder? This is more or less the same, but the \u0026ldquo;Android way\u0026rdquo;. There are of course multiple Layouts available.\nBrowse through the ConstraintLayout documentation and watch the short introduction video on how to build interfaces with it. It allows for multiple flexible ways to define constraints that dictate the position of the components: relative positioning, margins, centering, circular positioning, chaining, dimension constraining, and so forth. We\u0026rsquo;ll minimize complexity by resorting to the GUI-editor embedded into Android Studio instead of writing too much UI-specific code.\nFiddle with the layout editor to place the six needed components for the login screen.\n Inspect and modify desired properties of components if needed in the right-hand pane of the Design Editor (especially the ID on the top-right):\n  Changing the text property of a TextView.  Without specifying constraints, the components will be re-positioned to (0, ) after publishing to your device. To add constraints, drag the circles to touching edges of the ConstraintLayout, or to other elements present in the activity. This \u0026ldquo;locks\u0026rdquo; the component, allowing it only to move by adhering to the constraints. After setting all constraints, try moving one of the components: others will move along with it due to the constraints.\nAdding actions Once you\u0026rsquo;ve got a login button up and running, it would be nice if it actually did something when pressing it. The easiest way to do that is to use Android View Binding:\n View binding is a feature that allows you to more easily write code that interacts with views. Once view binding is enabled in a module, it generates a binding class for each XML layout file present in that module. An instance of a binding class contains direct references to all views that have an ID in the corresponding layout.\n To enable, simply add the buildFeature in your build.gradle.kts file:\nandroid { ... buildFeatures { viewBinding = true } } After refreshing, every XML layout file will be accompanied by a secretly generated Java file that contains the items to access and attach events to. The name of the binding class is generated by converting the name of the XML file to Pascal case and adding the word \u0026ldquo;Binding\u0026rdquo; to the end. activity_main.xml will thus have an ActivityMainBinding class.\nIn your \u0026ldquo;controller\u0026rdquo; (you do remember the Model-View-Controller pattern, right?) that extends from AppCompatAcitivy, add a lateinit binding field, and refer to it using inflate(). Then, we\u0026rsquo;ll set the content view to that particular binding root. If that is done, we can add events:\nclass MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ActivityMainBinding.inflate(layoutInflater) // warning, this is changed, it used to be R.main.id  setContentView(binding.root) // just to prove things changed  binding.btnLogin.setText(\u0026#34;lol\u0026#34;) } } In JavaFX, this is a bit simpler (at first):\npublic class SomeController { @FXML private BUtton btnLogin; @FXML public void initialize() { btnLogin.setOnClick.... } } Here, we can create fields and auto-wire them. In Android, you have to rely on the generated binding class where the fields are: less messy but one more step needed to take. Remember that the more components you have, the more convoluted your FXML Controller is going to get. This is well-hidden behind the binding object in Android systems.\nWe react to events such as the click (\u0026ldquo;tap\u0026rdquo;) event in the same way as you would do in JavaFX:\nbinding.btnLogin.setOnClickListener { view -\u0026gt; Snackbar.make(view, \u0026#34;Nice, clicked a button\u0026#34;, Snackbar.LENGTH_LONG).setAction(\u0026#34;Action\u0026#34;, null).show() } binding.getLoginButton().setOnClickListener(new OnClickListener() { @Override public void onClick(View var1) { Snackbar.make(view, \u0026#34;Nice, clicked a button\u0026#34;, Snackbar.LENGTH_LONG).setAction(\u0026#34;Action\u0026#34;, null).show(); } })  If you can\u0026rsquo;t make sense of the lambda syntax, take a peek at the conventional Java implementation.\nSnackbar is a fast way to provide periodical feedback that automatically disappears. Ta-daa:\n   What else are possible events you can listen to?\n setOnCapturedPointerListener setOnApplyWindowInsetsListener setOnFocusChangeListener setOnDragListener setOnKeyListener setOnHoverListener \u0026hellip;  Retrieve the password value and check it with some hard-coded value. If not correct, show a warning message using a Snackbar. If the username is empty, also show a warning message.\n  Adding a second Activity What should happen once we\u0026rsquo;re logged in successfully? Take another look at the first image on this page: a welcome screen would be nice.\nCreate a second layout XML file by right-clicking on the res folder (or layout), select New \u0026ndash; Layout Resource File, and name it activity_welcome. You\u0026rsquo;re given the option to change the root element, but another ConstraintLayout is fine, since we\u0026rsquo;re now familiar with the basics of element placing in that particular layout. Go to the design editor and pull in a nice welcome text and a sample image that corresponds to the user\u0026rsquo;s avatar. When you\u0026rsquo;re done with that, create the corresponding controller class called WelcomeActivity.\nNext, we need a piece of code to change the activity to the new one, provided the password is correct. That\u0026rsquo;s done using an Intent, of which we\u0026rsquo;ll see more in the coming chapter. An intent is a way to pass messages from one activity to another, but also to tell one activity it should transition to the other:\nval intent = Intent(this, MyNewActivity::class.java) startActivity(intent) Intent intent = new Intent(this, MyNewActivity.class) startActivity(intent)  Note that ::class.java is the Kotlin way to grab hold of the static .class instance of a class. Run your app and see if it works. Chances are you\u0026rsquo;ll see it crash with the following message in the console:\nE/AndroidRuntime: FATAL EXCEPTION: main Process: be.kuleuven.login, PID: 8457 android.content.ActivityNotFoundException: Unable to find explicit activity class {be.kuleuven.login/be.kuleuven.login.WelcomeActivity}; have you declared this activity in your AndroidManifest.xml? at android.app.Instrumentation.checkStartActivityResult(Instrumentation.java:2065) at android.app.Instrumentation.execStartActivity(Instrumentation.java:1727) at android.app.Activity.startActivityForResult(Activity.java:5320) Whoops. Each activity needs to be defined in the AndroidManifest.xml file where you can specify which one is the \u0026ldquo;main\u0026rdquo; that needs to be boostrapped as your application launches. Add an \u0026lt;activity/\u0026gt; tag there and try to guess the correct properties. Android Studio will auto-complete things for you. Make sure exported is set to true.\nTry again and it should work!\nA note on (text) sizes: in Common Attributes, changing the text size means selecting a unit in sp, not px. What\u0026rsquo;s an sp? To be able to support different pixel densities of different screens, we do not rely on hard-coded pixels but let this be calculated. SP = Scalable Pixels and is used for scaling text. Otherwise, use dp. DP = Density-Independent Pixels. See the andorid multiscreen dev guide for more information on how pixels are effectively calculated. Watch the video to get a better grasp of Android\u0026rsquo;s logical pixel densities. Never use px! The same is true for graphic assets, but to avoid automatic scaling which usually ruins your PNGs, provide at least four different versions: one for each dp \u0026ldquo;bucket\u0026rdquo;: MDPI, HDPI, XHDPI and XXHDPI. Again, see the documentation.\n To learn more about message passing, see messaging: intents.\nThe lifecycle of an activity See Android Developer Guide: Understanding the Activity Lifecycle\nSo far, we have leveraged the onCreate() state to wire together things like events and fetch our binding object. However, an activity has multiple stages to go through, and each of them can be hooked into if desired. onCreatae() just so happens to be the first (obligatory!) callback to implement, next to other five important ones: onStart(), onResume(), onPause(), onStop(), and onDestroy(). Take a look at this schematic to see how they relate to each other:\n  A simplified illustration of the activity lifecycle. Src: android.developer.com  As soon as the user navigates from our main activity to MyNewActivity, the main activity will be paused. Pressing BACK causes onResume() to trigger, while the other activity will be paused. When the second activity was successfully (1) created, (2) started and (3) resumed, the previous one will be stopped. Pressing back results in (1) second paused, (2) main started and (3) resumed, so that (4) second is stopped and ultimately (5) destroyed. Try it yourself!\nImplement all six callbacks on the two activities (see above, section \u0026ldquo;Adding a second Activity\u0026quot;). Print a message (in the console if debugging, or using a simple Toast message) for each one to get a sense of what state the application/activity is in. You\u0026rsquo;ll notice that onResume() is also always called during launch.\n  Saving and restoring UI state Besides obvious uses such as saving draft text in onStop(), knowing about the lifecycle is important because as soon as the user rotates the device or switches into multi-window mode, the current activity is destroyed and restarted. The problem is that any UI state is wiped away, but the user still expects an activity\u0026rsquo;s UI state to be persistent!\nFor each activity you design, think about its implications. What does the user expect when he or she returns to it? Should it be wiped? Yes? No? User expectations ans system behavior should match. The Android Dev Guide states:\n Depending upon the action a user takes, they either expect that activity state to be cleared or the state to be preserved. In some cases the system automatically does what is expected by the user. In other cases the system does the opposite of what the user expects.\n In order to save additional instance data before the rotation transition occurs, override onSaveInstanceState() and put data in the Bundle object:\noverride fun onSaveInstanceState(outState: Bundle) { outState.run { putString(\u0026#34;name\u0026#34;, binding.txtUsername.text.toString()) } super.onSaveInstanceState(outState) } Retrieval is possible in onRestoreInstamceState(), or even in onCreate() if for whatever reason the Android OS decided to destroy your activity and recreate it. Make sure to check the contents of the single argument. isEmpty() is a handy check function.\nThere are a plethora of options for preserving and restoring UI state. See saving states docs: use a viewmodel, use raw instance state such as the example above, or even persistent storage. All options come with their own advantages and disadvantages.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/extra/faq/",
	"title": "2. Common Errors FAQ",
	"tags": [],
	"description": "",
	"content": "1. minSdkVersion mismatch Error:\n \u0026ldquo;Expected minSdkVersion \u0026gt;= 21 but found 1\u0026rdquo;\n Cause: mismatch in build.gradle of android SDK and configured SDK in your emulator.\nSolution: just keep these the same. The error disappeared here after selecting for example 30/30.\n2. Emulator process was killed? Error:\n Emulator: process was killed\n Cause: a hundred different things. Consult the Android Studio error log for more details\u0026mdash;these aren\u0026rsquo;t displayed in the IDE. Either pick Help \u0026ndash; show Log (or show Log in Finder if you\u0026rsquo;re on a Mac), or locate it on the HDD (Mac: ~/Logs/Google/AndroidStudioPreviewX, Win: C:\\Users\\\u0026lt;name\u0026gt;\\.AndroidStudioX\\system\\log)\nFind the process was killed message, and you\u0026rsquo;ll likely see another error that caused that one. For instance:\n Too little disk space. Logged in as root user in Linux. .ini file could not be found. x86 emulator installed on an x64-architecture system Apple M1 silicon-related errors if you did not install the latest preview edition.  3. Virtualization HAXVM-related errors Error:\n Unable to install Intel® HAXM\n Or:\n Your CPU does not support VT-x.\n Or:\n Unfortunately, your computer does not support hardware accelerated virtualization.\n Cause 1: Are you on a Mac M1 and did you install the latest release instead of the preview release? You need to download an Android Virtual Device based on an ARM systems image. This is done automatically in the latest preview edition of Android Studio. See installation guide.\nCause 2: Are you on a 64-bit system but did you install 32-bit emulators or components? Pay careful attention to the processor architecture of the installation and your machine\u0026mdash;these should match!\n4. Invalid Entry CRC while deploying Error:\n Failed to transform material-1.3.0.aar invalid entry CRC expected 0x9797\u0026hellip; but got 0x48546\u0026hellip;.\n Cause: I have no idea, and Google/Stack Overflow doesn\u0026rsquo;t seem to know either. It happens sometimes after building and deploying. The emulator boots, but the app won\u0026rsquo;t load in the emulator.\nSolution: Rebuild. Do not restart the emulator, just leave it open. Simply rebuilding seems to fix this problem.\n5. LifecycleOwners must call register before they are STARTED. Error:\n \u0026hellip; is attempting to register while current state is STARTED. LifecycleOwners must call register before they are STARTED.\n Cause:\nAre you calling registerForActivityResult in onCreate() using a callback of sorts? If so, your fragment/activity is still in STARTED state and should be in CREATED state for this particular intent to receive the results. Usually if you want to receive a camera image.\nSolution: move your listener outside of create scope (e.g. onViewCreated()).\n6. NoActivityResumedException when running instrumented tests Error:\nandroidx.test.espresso.NoActivityResumedException: No activities found. Did you forget to launch the activity by calling getActivity() or startActivitySync or similar? at dalvik.system.VMStack.getThreadStackTrace(Native Method) at java.lang.Thread.getStackTrace(Thread.java:1736) at androidx.test.espresso.base.DefaultFailureHandler.getUserFriendlyError(DefaultFailureHandler.java:12) at androidx.test.espresso.base.DefaultFailureHandler.handle(DefaultFailureHandler.java:7) at androidx.test.espresso.ViewInteraction.waitForAndHandleInteractionResults(ViewInteraction.java:8) at androidx.test.espresso.ViewInteraction.desugaredPerform(ViewInteraction.java:11) at androidx.test.espresso.ViewInteraction.perform(ViewInteraction.java:4) at be.kuleuven.login.MainActivityTests.givenCorrectPassword_whenLoginPressed_thenTransitionToWelcome(MainActivityTests.kt:60) Cause: you forgot to bootstrap an activity in your test using @get:Rule and @Before/@After methods. See the Kotlin/Android TDD chapter for more information.\nSolution: Initialize your activity before making any assumptions!\n7. Build failures: KaptWithoutKotlincTask$\u0026hellip; Error:\nFAILURE: Build failed with an exception. * What went wrong: Execution failed for task ':app:kaptDebugKotlin'. \u0026gt; A failure occurred while executing org.jetbrains.kotlin.gradle.internal.KaptWithoutKotlincTask$KaptExecutionWorkAction \u0026gt; java.lang.reflect.InvocationTargetException (no error message) Cause: You\u0026rsquo;ve enabled kotlin-kapt\u0026mdash;probably for Room database tooling. That means you\u0026rsquo;ve done something wrong in your Dao or object-to-save. For instance, made the primary key an immutable val instead of a var. Re-check your database objects and make sure everything is as it should be!\nBuild radle with ./gradle build --stacktrace to get more output and see the underlying exception.\nSolution: fix the Room-specific mistakes (annotation-related). Another possible cuse is your M1 Mac chipset: see data storage, add the kapt \u0026quot;org.xerial:sqlite-jdbc:3.34.0\u0026quot; dependency yourself.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/lang/kotlin-advanced/",
	"title": "2. Kotlin programming: Advanced",
	"tags": [],
	"description": "",
	"content": "A closer look at Java/Kotlin interop As seen in the kotlin basics, both languages compile to .class files that the JVM can understand. And since class files can be decompiled by the likes of procyon, let\u0026rsquo;s see what happens when we do that to a bit of Kotlin code, just to deepen our understanding of how Kotlin works in relation to Java.\nSuppose we build a joinToString function to print out a string representation of a collection with separators. Copy the following to a single file called collections.kt:\nfun \u0026lt;T\u0026gt; joinToString(collection: Collection\u0026lt;T\u0026gt;, separator: String = \u0026#34;:\u0026#34;, prefix: String = \u0026#34;[\u0026#34;, suffix: String = \u0026#34;]\u0026#34;): String { val builder = StringBuilder(prefix) for((index, element) in collection.withIndex()) { if(index \u0026gt; 0) builder.append(separator) builder.append(element) } builder.append(suffix) return builder.toString() } data class Person(val name: String, val age: Int) fun main() { val someCollection = mapOf(\u0026#34;Jos\u0026#34; to Person(\u0026#34;Jos\u0026#34;, 20), \u0026#34;Lowie\u0026#34; to Person(\u0026#34;Lowie\u0026#34;, 56)) println(joinToString(someCollection.values)) println(joinToString(someCollection.values, \u0026#34;, \u0026#34;, prefix = \u0026#34;(\u0026#34;, suffix = \u0026#34;)\u0026#34;)) } A few things that would be impossible to do in Java;\n Every class should be inside the same-named file. That is, the Person \u0026ldquo;data\u0026rdquo; (does not exist in Java) class should reside in a separate file. Top-level functions do not exist and should be placed in static classes. Default arguments do not exist. Java code is usually heavily overloaded, with a lot of duplication as a consequence. Non-nullable references do not exist in Java. We did not use ?, so the arguments to joinToString cannot be null. The easy-access index/value for loop and withIndex() does not exist in Java. Creating tuples using an infix notation: \u0026quot;Jos\u0026quot; to Person().  Create your own infix notation functions by prepending functions with infix. For example, an expressive way to add two numbers could be infix fun Int.plus(other: Int): Int = this + other. That way, you can write 2 plus 3 instead of 2.plus(3)! See the kotlin docs for more details.\n When building using IntelliJ, the output consists of two files in build/classes, perhaps as expected:\n CollectionsKt.class Person.class  Let\u0026rsquo;s decompile the collections file using java -jar procyon-decompiler.jar path/to/CollectionsKt.class. The output is the following Java code:\n// // Decompiled by Procyon v0.6-prerelease //  package be.kuleuven.adv; import java.util.Map; import kotlin.collections.MapsKt; import kotlin.TuplesKt; import kotlin.Pair; import java.util.Iterator; import kotlin.jvm.internal.Intrinsics; import org.jetbrains.annotations.NotNull; import java.util.Collection; import kotlin.Metadata; @Metadata(mv = { 1, 5, 1 }, k = 2, xi = 48, d1 = { \u0026#34;\\u0000 \\n\\u0000\\n\\u0002\\u0010\\u000e\\n\\u0002\\b\\u0002\\n\\u0002\\u0010\\u001e\\n\\u0002\\b\\u0004\\n\\u0002\\u0010\\u0002\\n\\u0000\\n\\u0002\\u0010\\u0011\\n\\u0002\\b\\u0002\\u001a8\\u0010\\u0000\\u001a\\u00020\\u0001\\\u0026#34;\\u0004\\b\\u0000\\u0010\\u00022\\f\\u0010\\u0003\\u001a\\b\\u0012\\u0004\\u0012\\u0002H\\u00020\\u00042\\b\\b\\u0002\\u0010\\u0005\\u001a\\u00020\\u00012\\b\\b\\u0002\\u0010\\u0006\\u001a\\u00020\\u00012\\b\\b\\u0002\\u0010\\u0007\\u001a\\u00020\\u0001\\u001a\\u0019\\u0010\\b\\u001a\\u00020\\t2\\f\\u0010\\n\\u001a\\b\\u0012\\u0004\\u0012\\u00020\\u00010\\u000b¢\\u0006\\u0002\\u0010\\f¨\\u0006\\r\u0026#34; }, d2 = { \u0026#34;joinToString\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;T\u0026#34;, \u0026#34;collection\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;separator\u0026#34;, \u0026#34;prefix\u0026#34;, \u0026#34;suffix\u0026#34;, \u0026#34;main\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;args\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;([Ljava/lang/String;)V\u0026#34;, \u0026#34;advanced-snippets\u0026#34; }) public final class CollectionsKt { @NotNull public static final \u0026lt;T\u0026gt; String joinToString(@NotNull final Collection\u0026lt;? extends T\u0026gt; collection, @NotNull final String separator, @NotNull final String prefix, @NotNull final String suffix) { Intrinsics.checkNotNullParameter((Object)collection, \u0026#34;collection\u0026#34;); Intrinsics.checkNotNullParameter((Object)separator, \u0026#34;separator\u0026#34;); Intrinsics.checkNotNullParameter((Object)prefix, \u0026#34;prefix\u0026#34;); Intrinsics.checkNotNullParameter((Object)suffix, \u0026#34;suffix\u0026#34;); final StringBuilder builder = new StringBuilder(prefix); final Iterator\u0026lt;? extends T\u0026gt; iterator = collection.iterator(); int n = 0; while (iterator.hasNext()) { final int index = n; ++n; final Object element = iterator.next(); if (index \u0026gt; 0) { builder.append(separator); } builder.append(element); } builder.append(suffix); final String string = builder.toString(); Intrinsics.checkNotNullExpressionValue((Object)string, \u0026#34;builder.toString()\u0026#34;); return string; } public static /* synthetic */ String joinToString$default(final Collection collection, String separator, String prefix, String suffix, final int n, final Object o) { if ((n \u0026amp; 0x2) != 0x0) { separator = \u0026#34;:\u0026#34;; } if ((n \u0026amp; 0x4) != 0x0) { prefix = \u0026#34;[\u0026#34;; } if ((n \u0026amp; 0x8) != 0x0) { suffix = \u0026#34;]\u0026#34;; } return joinToString((Collection\u0026lt;?\u0026gt;)collection, separator, prefix, suffix); } public static final void main(@NotNull final String[] args) { Intrinsics.checkNotNullParameter((Object)args, \u0026#34;args\u0026#34;); final Map someCollection = MapsKt.mapOf(new Pair[] { TuplesKt.to((Object)\u0026#34;Jos\u0026#34;, (Object)new Person(\u0026#34;Jos\u0026#34;, 20)), TuplesKt.to((Object)\u0026#34;Lowie\u0026#34;, (Object)new Person(\u0026#34;Lowie\u0026#34;, 56)) }); System.out.println((Object)joinToString$default(someCollection.values(), null, null, null, 14, null)); System.out.println((Object)joinToString(someCollection.values(), \u0026#34;, \u0026#34;, \u0026#34;(\u0026#34;, \u0026#34;)\u0026#34;)); } } What\u0026rsquo;s interesting here?\n Kotlin generated a class named CollectionsKt to match the filename. All our top-level functions are converted to public static final methods. checkNotNullParameter() is sprinkled around everywhere\u0026mdash;even just before returning values. The fancy for loop has been replaced by a not-so-fancy while(iterator.hasNext()): plain old (ugly) Java code. a second $default method has been generated because we call joinToString() two times using different arguments: once with no defaults provided, once with all provided. Array\u0026lt;String\u0026gt; in our main method is indeed a String[] classic Java array. Default values are filled in if arguments are empty with generated if{} checks. to turns out to be a method in TuplesKt, not a construct of the language! Semicolons are back!  To conclude, we can assume that the Kotlin compiler always spews out fully Java-complaint code in such a way that our classic Java projects seamlessly integrate with the more modern language. The only problem is the import kotlin. statements, where the kotlin runtime jar is required to be in the classpath.\nIf you do not understand the syntax of Kotlin at one point. decompile the class file. Try to compile and decompile some of the provided advanced snippets in the course repository and you\u0026rsquo;ll gain a much better understanding of the inner workings of both Kotlin and Java. We highly recommend you try to do this at least once!\n A class inheritance example Since class files are final by default, you\u0026rsquo;ll need to add the open keyword to classes you\u0026rsquo;d like to extend from.\nSubclassing, getters/setters, equality checks Below is another elaborated example that demonstrates some of Kotlin\u0026rsquo;s inheritance quirks:\npackage be.kuleuven.adv open class Animal() { } interface Plays { fun play() } // without \u0026#34;open\u0026#34; in Animal\u0026#39;s definition, this wouldn\u0026#39;t work // classes are FINAL by default! // \u0026#34;implements\u0026#34; and \u0026#34;extends\u0026#34; are both replaced by a semicolon open class Monkey(val name: String) : Animal(), Plays { lateinit var hobbies: String private set // all paths to all constructors MUST initialize this  // otherwise: Exception in thread \u0026#34;main\u0026#34; kotlin.UninitializedPropertyAccessException: lateinit property hobbies has not been initialized  // since the primary constructor doesn\u0026#39;t do this, we\u0026#39;ll need an \u0026#34;init\u0026#34; block for it instead.  init { hobbies = \u0026#34;Boring myself to death with a rock or perhaps a small bush of grass\u0026#34; } constructor(name: String, hobbies: String) : this(name) { this.hobbies = hobbies } constructor(twinbrother: Monkey): this(twinbrother.name, twinbrother.hobbies) override fun play() { println(\u0026#34;ooh ooh aah aah monkey see monkey do?\u0026#34;) } // Note that since it\u0026#39;s a standard Java equals, the argument can be null  // Note that after calling \u0026#34;is?, the argument automagically is class-casted! Wowza! Check out the decompiled source to see the magic:  /* @Override public boolean equals(@Nullable final Object other) { return other != null \u0026amp;\u0026amp; other instanceof Monkey \u0026amp;\u0026amp; Intrinsics.areEqual((Object)((Monkey)other).name, (Object)this.name) \u0026amp;\u0026amp; Intrinsics.areEqual((Object)((Monkey)other).getHobbies(), (Object)this.getHobbies()); } */ override fun equals(other: Any?): Boolean { if(other == null || other !is Monkey) return false return other.name == name \u0026amp;\u0026amp; other.hobbies == hobbies } } class VeryPrivateMonkey private constructor(): Monkey(\u0026#34;I\u0026#39;d rather not say\u0026#34;) fun main() { val george = Monkey(\u0026#34;George\u0026#34;) val jeffrey = Monkey(george) // can\u0026#39;t. there\u0026#39;s a \u0026#34;private\u0026#34; constructor  // Seems easier in Java, isn\u0026#39;t it?  // val anonymous = VeryPrivateMonkey()  george.play() jeffrey.play() println(\u0026#34;Are George and Jeffrey alike? \u0026#34; + (george == jeffrey)) } The above code demonstrates the following concepts:\n Access modifiers, and custom ones in a setter primary and secondary constructors init blocks and late binding on properties the obligatory explicit usage of the keyword override how to implement a basic equals method the Kotlin way how to use that equality check: with == instead of .equals(). The identity/reference check uses three = signs: ===, as in JavaScript.  Interfaces, default implementations, properties Suppose we want to oblige the implementation of a getter of a property, but we\u0026rsquo;re building an interface, not a class. In Kotlin, you can add properties to interfaces: these will generate getProperty() function definitions one has to override:\npackage be.kuleuven.adv // note that these implementations generate four different class files: NameProvider, NickNameProvider, PoshNameProvider, and [FilenameKt] // see build/classes/kotlin  // interfaces can hold properties. There are just getter method definitions // interfaces can hold default implementations. (JDK 8+, this is also legal in Java) interface NameProvider { val name: String val email: String get() { return \u0026#34;$name@hotmail.com\u0026#34; } } // We have to provide the \u0026#34;getName()\u0026#34; method, but we\u0026#39;re simply creating a backing field here class NickNameProvider(override val name: String) : NameProvider // Alternatively, implement the getter. class PoshNameProvider() : NameProvider { override val name: String get() = \u0026#34;Prof. Dr. Genius\u0026#34; } fun main() { val myProf = PoshNameProvider() val me = NickNameProvider(\u0026#34;Exterminator 2000\u0026#34;) println(\u0026#34;Reach me at ${me.email}- following a lecture of ${myProf.name}\u0026#34;) } The above code demonstrates the following concepts:\n Properties in interfaces, with custom getters that reference to others if needed. Note that you cannot dictate where to store the value: it\u0026rsquo;s an interface, after all. Implementing that interface and simply using override val in the primary constructor to satisfy the constraints. Implementing the getter yourself manually. Again, class bodies that are empty (class bla {}) are redundant: there are no curly braces used in the definition of NickNameProvider. Again, string interpolation, not limited to a single expression, using curly braces inside double quotes.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/intents/",
	"title": "2. Messaging - Intents",
	"tags": [],
	"description": "",
	"content": "Using intents to start an internal activity What if, instead of showing a generic welcome screen after logging in, we want to personally welcome the user?\nInstead of \u0026ldquo;Welcome, have a nice day\u0026rdquo;, as pictured in:\n  Two example activities from 1.1.  We\u0026rsquo;d like to say \u0026ldquo;Welcome [username]\u0026rdquo;! That is, we want to pass arguments from one activity to the next. We\u0026rsquo;ve already created an intent to start a second activity using Intent(this, MyNewActivity::class.java). After this piece of code, and before calling startActivity(), we can add stuff to the intent which is passed along the new activity:\nval intent = Intent(this, WelcomeActivity::class.java) intent.putExtra(\u0026#34;username\u0026#34;, binding.txtUsername.text.toString()) startActivity(intent) On the receiving side, simply pull out the data using the appropriate get function in the onCreate() function after setting the content view to the correct root binding:\nval username = intent.getStringExtra(\u0026#34;username\u0026#34;) binding.txtWelcome.text = \u0026#34;Welcome, $username\u0026#34; Passing objects through intents Of course, passing in tens of different input fields can get cumbersome. Instead, let\u0026rsquo;s provide a data class that represents the user:\ndata class User(val name: String) public class User { private final String name; public String getName() { return name; } @Override public void toString() { return \u0026#34;[\u0026#34; + name + \u0026#34;]\u0026#34;; } @Override public bool equals(object other) { if(other == null || other !instanceof User) { return false; } User otherUser = (User) other; return name.equals(otherUser.name); } @Override public int hashCode() { return name.hashCode(); } }  Remember that data classes are convenient ways to automatically implement getters/setters/equals/hashcode/tostring. Take a look at the Java code and try not to freak out. It\u0026rsquo;s that ugly.\nUnfortunately, that is not enough. Intents only carry along basic key-value pairs of primitives, meaning our object has to be serialized. There are two options to do this:\n The default Java way: implement Serializable. Use Kotlin native serialization to make things easier here. The Android specific way: implement Parcelable. A \u0026ldquo;parcel\u0026rdquo; is a \u0026ldquo;package\u0026rdquo; that needs to be delivered form one side to the other. Parcels are much more efficient on Android devices than serializable. See the parcelable implementation generator docs on how to enable this in your Kotlin-Android project.  Let\u0026rsquo;s settle with the first option. In order to add @Serializable to your data class, we need to install the kotlinx.serialization plugin. Add the plugin to your plugins block in your module build.gradle.kts (keep the version the same as your Kotlin version!):\nplugins { id(\u0026#34;com.android.application\u0026#34;) id(\u0026#34;kotlin-android\u0026#34;) kotlin(\u0026#34;plugin.serialization\u0026#34;) version \u0026#34;1.5.21\u0026#34; // add this } Then, add an implementation dependency  implementation(\u0026quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.2.2\u0026quot;). Lastly, update your User data class to add the @Serializable annotation that should get imported from the package kotlinx.serialization, and the Java Serializable interface to tell Android-specific methods it\u0026rsquo;s a serializable object:\n@Serializable data class User(val name: String) : java.io.Serializable { } Now create a function that returns a new User object based on the viewbinding\u0026rsquo;s values. Then pass the single User instance through the intent using putExtra(). Pull it back out using getSerializableExtra().\nAndroid also supports (two-way) data binding, next to the view binding system introduced in chapter 1.1. This allows designers to directly map properties of models into the layouts, thus avoiding having to access every single property to carry over into an intent or another object. Data binding is not part of this course but feel free to use it instead of view binding, should you wish to do so.\n Can you think of other smart ways to share data between activites?\nThe Parcelize alternative is left as an exercise for the reader.\nUsing intents to start an internal service Besides switching activities as screens within a single app, an intent can also pass messages along a background service that performs operations without a user interface. Services can be launched by creating a JobScheduler instance and passing it to startService() (instead of startActivity()) (see API reference). Why would you want to do that?\n To download a large file in the background without blocking the UI To convert a lot of images in the background To upload data to a back-end server using a HTTP POST \u0026hellip;  Services, and the difference between them and typical Java threads, are explained in detail in the Services overview dev guide.\nThe usage of services is not part of this course.\nUsing intents to interact with other apps Implicit intents When you create an intent to switch to an activity, your own app knows how to handle that intent: it should go to that new activity that also lives within your own app. These are called explicit intents: you specify which application will satisfy the intent by supplying the class name of the activity.\nNext to explicit intents, you can also create implicit intents. What\u0026rsquo;s that? According to the docs:\n Implicit intents do not name a specific component, but instead declare a general action to perform, which allows a component from another app to handle it. For example, if you want to show the user a location on a map, you can use an implicit intent to request that another capable app show a specified location on a map.\n Some useful uses of implicit intents:\n Ask \u0026ldquo;any app\u0026rdquo; to take a picture and return a reference to us Ask \u0026ldquo;any app\u0026rdquo; to browse on a map to a specific location Ask \u0026ldquo;any app\u0026rdquo; to print something Ask \u0026ldquo;any app\u0026rdquo; to dail a number \u0026hellip;  In short, messaging between specific apps requires the creation of implicit intents that you do NOT handle yourself.\nThe code for this is really simple:\nval number = Uri.parse(\u0026#34;tel:011112233\u0026#34;) startActivity(Intent(Intent.ACTION_CALL, number)) Each system-wide known implicit intent is specified with a pre-defined String that can be auto-completed:\n  the Auto-completion lists of possible (implicit) intents.  See the guide to intents for more examples such as opening a map, a webpage, creating an e-mail with attachments, and so forth.\nApplications that are not allowed to make calls will generate a SecurityException while attempting to start the action.CALL intent with the message \u0026ldquo;Permission Denial\u0026rdquo;, stating which specific permission is missing (android.permission.CALL_PHONE in case of calling). Add these in your android manifest file if needed. More on that in the security by design chapter.\n In case no single application knows how to handle your implicit intent, not even your own, startActivity() will throw an ActivityNotFoundException. It would thus be in your best interest to wrap your activity starts with a try block!\nA much better, secure way of coding would be to protect implicit intents with runtime checks. Suppose you want to open the camera and afterwards receive the image URI. The app you want might simply not be there on certain devices, or that the user has restricted profile access. The key idea here is to check something before using it, instead of letting it crash afterwards. That\u0026rsquo;s done via resolveActivity():\nval intent = Intent(Intent.ACTION_CALL, number) if(intent.resolveActivity(applicationContext.packageManager) != null) { startActivity(intent) } else { msg(\u0026#34;doesnt work on your device mate\u0026#34;) } This has known issues in certain Amdroid API versions. A fallback would be to still catch the exception.\nRetrieving the result from intents Let\u0026rsquo;s try to capture a picture. Follow along in the taking photos Android Dev guide. Remember advertise that your app depends on having a camera by adding \u0026lt;uses-feature android:name=\u0026quot;android.hardware.camera\u0026quot; android:required=\u0026quot;true\u0026quot; /\u0026gt; in the manifest file. The intent we\u0026rsquo;re going to use is MediaStore.ACTION_IMAGE_CAPTURE.\nFirst, we need to register an \u0026ldquo;activity result\u0026rdquo; in our onCreate(), because it is only safe to call the method before the activity is in its STARTED state:\nclass MainActivity : AppCompatActivity() { private lateinit var pictureActivityResult: ActivityResultLauncher\u0026lt;Void\u0026gt; // ...  override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // ...  pictureActivityResult = registerForActivityResult(ActivityResultContracts.TakePicturePreview()) { bm: Bitmap -\u0026gt; msg(\u0026#34;bitmap is ${bm.height}high\u0026#34;, binding.root) // do something with the captured image  } } Next, in the onclick listener, after asking/checking for the correct permissions, fire off the result using pictureActivityResult.launch(null).\nNow where exactly do we specify which intent to fire off? That magic is obfuscated inside the TakePicturePreview class we\u0026rsquo;re instantiating. You can provide your own what is called activity contracts, but a lot of commons are provided for you in the ActivityResultcontracts class. The picture preview source code looks like this:\npublic static class TakePicturePreview extends ActivityResultContract\u0026lt;Void, Bitmap\u0026gt; { @CallSuper @NonNull @Override public Intent createIntent(@NonNull Context context, @Nullable Void input) { return new Intent(MediaStore.ACTION_IMAGE_CAPTURE); } @Nullable @Override public final SynchronousResult\u0026lt;Bitmap\u0026gt; getSynchronousResult(@NonNull Context context, @Nullable Void input) { return null; } @Nullable @Override public final Bitmap parseResult(int resultCode, @Nullable Intent intent) { if (intent == null || resultCode != Activity.RESULT_OK) return null; return intent.getParcelableExtra(\u0026#34;data\u0026#34;); } } Aha, now we\u0026rsquo;re getting somewhere! Upon further inspection, TakePicture (not the preview one) puts extra data into the intent to capture the whole output. Note the first generic type of the extended class: Void. So that is where that Void comes from in or lateinit var pictureActivityResult: other embedded activity result contracts will likely have other result types (OpenDocument has String[], for instance). These details are provided for you, make use of them.\nNote that because of the implicit intent, handling the camera is left to another app which is already has permissions to access the camera. Therefore, we do NOT need an explicit \u0026lt;uses-permission android:name=\u0026quot;android.permission.CAMERA\u0026quot; /\u0026gt; entry in our manifest, but it\u0026rsquo;s still important to advertise we do use the camera with a \u0026lt;uses-feature/\u0026gt; tag. See the security by design chapter for more information.\nYou\u0026rsquo;ll learn the most while digging through the source code of the API itself while hacking your way through the code\u0026mdash;and not by just reading this page. Do not be afraid to press CTRL+B (Go To Declaration) in Android Studio! If you still have no idea what\u0026rsquo;s going on, then developer.android.com is your best friend.\n Delivering/receiving a broadcast Instead of keeping intents as messages within your application, you can also broadcast them so that any app can receive them. The system delivers various broadcasts for system events, such as on bootup or when the device starts charging. Sending broadcasts can be done through sendBroadcast().\nTODO in or out? what about them?\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/fragments/",
	"title": "3. Complex layouts: Fragments",
	"tags": [],
	"description": "",
	"content": "See also: Android developer guide: fragments.\nWhat\u0026rsquo;s a fragment? A fragment is, simply put, a reusable UI portion of an activity. For example, the welcome message from the activities chapter can be a separate fragment, and the image containing the avatar of the user can be a separate fragment. Fragments are programmatically created by extending from Fragment from package androidx.fragment.app.\nFrom the docs:\n A Fragment represents a reusable portion of your app\u0026rsquo;s UI. A fragment defines and manages its own layout, has its own lifecycle, and can handle its own input events. Fragments cannot live on their own\u0026ndash;they must be hosted by an activity or another fragment. The fragment’s view hierarchy becomes part of, or attaches to, the host’s view hierarchy.\n Until now, we have not explicitly used fragments: we have directly created UI components on top of activities by dragging them in the design editor onto the designated layout. In most cases, that would be a single ConstraintLayout that uses constraints to specify where that particular button and text input component should be placed. When integrating fragments into an activity, these things do not change: instead of putting them directly onto the activity, you simply configure them on the fragment, and put one or more fragments onto an activity. In other words, it\u0026rsquo;s another abstraction layer.\nA few things to remember:\n Fragments have their own lifecycle There\u0026rsquo;s always an activity that holds one or more fragments (the parent container), and fragments are affected by the lifecycle of the activity.  Why use fragments? Reusability/Modularity The easiest way to demonstrate its use is through the following schematic:\n  src: Android docs  Suppose we develop an Android app that we know will be running on:\n A tablet with a big screen, where people usually hold it horizontally. A smartphone with a smaller screen that is usually held vertically.  On that smartphone screen, because of the dimensions, not all UI components can be shown at once. As a concrete example, just think about any master/detail screen you\u0026rsquo;ve ever used in a tablet or on a smartphone: the master screen, that displays a list of things to select, is always shown first, while after selecting something, the detail screen appears. On a tablet device or on a PC, we can show both screens at the same time! This effect is visible in your typical Mail client:\n  Left: the master screen with navigation. Right: the detail: zoomed in on a single mail.  Instead of designing two separate applications, we want to encapsulate these into a single one where we simply re-use the master part and the detail part! On a smaller screen, we split those into two separate activities. On a bigger screen, we simply show them both at once. Thus, we need something to capture the essence of this principle: hence the concept of fragments.\nCreating fragments Just treat them as UI components. That is, they are also defined in the layout .xml files, and they are also a part of your ConstsraintLayout (constraints omitted for brevity):\n\u0026lt;fragment android:name=\u0026#34;be.kuleuven.fragmentswitcher.FirstFragment\u0026#34; android:id=\u0026#34;@+id/myfragment\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; /\u0026gt; As with activities, they need their own Java/Kotlin class, so make sure to add the needed classes. (Rightclick, new -\u0026gt; Fragment -\u0026gt; Blank, this automatically creates the layout file. If your fragment is called FirstFragment, the layout file will be fragement_first). The gray \u0026lt;fragment/\u0026gt; box indicates just a ssection of the activity that will be replaced as fragments get swapped in and out! That means we don\u0026rsquo;t need to (re)create an entire activity, and the fragment can be re-used.\nIn the simplest possible form, the fragment companion class looks like this:\nclass FirstFragment : Fragment(R.layout.fragment_first) public class FirstFragment extends Fragment(R.layout.fragment_first) { }  Instead of returning inflater.inflate(R.layout.fragment_first, container, false) in an override of onCreateView(), simply pass your fragment ID to the super constructor. onCreateView() is the function where your view properties should be set, and not in onCreate(), where you\u0026rsquo;d likely put it if you\u0026rsquo;re used to working with activities.\nThe android:name property in the XML refers to the class name of the fragment you initially want the fragment container to hold. Boot up the application, and you\u0026rsquo;ll see your first fragment layout in the activity. However, if you want to change dynamically, change the fragment to a \u0026lt;FrameLayout/\u0026gt; (remove the name), and let\u0026rsquo;s add some code in the MainActivity onCreate():\nval firstFragment = FirstFragment() supportFragmentManager.beginTransaction().apply { replace(R.id.fragmentContainer, firstFragment) commit() } FirstFragment firstFragment = new FirstFragment(); Transaction transaction = supportFragmentManager.beginTransaction(); transaction.replace(R.id.fragmentContainer, firstFragment); transaction.commit();  See also: android dev guide: fragment transactions. Reboot the application and you\u0026rsquo;ll still see the first fragment. Use the same code in button click listeners to dynamically change when your application is running.\nFixing the back button While interacting with fragment-based applications, your users will likely expect the back button to work properly. That is, when they press \u0026ldquo;back\u0026rdquo;, they expect the previous \u0026ldquo;screen\u0026rdquo; to be shown. Whether that is an activity or a fragment is an implementation detail, not something an end user should be bothered with! However, replace() does not suffice. Add a call to addToBackStack() before the commit() and that problem is fixed.\nEverything in Android is pushed onto a stack. When the user wants to go back, an item is popped off the stack. When the user navigates to another screen\u0026mdash;be it activity or fragment\u0026mdash;, an item is (or should be) pushed onto the stack. Think of it as browsing the web using your cellphone. When you click on a link, and you decide you don\u0026rsquo;t like that site, you likely want to go back. How to go back? By pressing that \u0026lt; button, the previously loaded website suddenly reappears. This navigational experience is very important to smartphone users, and something Android app developers will want to emulate: using the back stack.\nRead more about the back stack in Android dev guide: understanding tasks and the back stack.\nThe lifecycle of a fragment See Android dev guide: fragment lifecycles. Another reminder that fragments have their own lifecycle, but are still affected by activity lifecycles. For example, onCreateView(), as mentioned above, does not exist in the activity lifecycle diagram, but does here:\n  src: developer.android.com  The biggest difference (and mistake to make) is to NOT access UI components in onCreate(), as the view isn\u0026rsquo;t initialized yet.\nSharing data between fragments The Android-recommended way to share data is to utilize viewModels, which are separate classes that can be bound to UI components to automatically update properties. However, this concept is out of scope for this course.\nA simpler, but more crude, way to exchange information is to simply create a separate class, acting as a model, and to set state on that shared instance. Pass it along the fragment\u0026rsquo;s constructor. See examples/kotlin/FragmentSwitcher in the course git repository for code examples.\nWhy use fragments? Easing navigation See Android Dev Guide: Navigation - getting started\nRemember the wireframe figure from the activities chapter?\n  An example wireframe that defines relationships between activities.  To navigate form one activity to the next, we simply created an Intent that starts the next one. This works for simple apps, but does not for more intricate designs: many different screens and many different ways to direct the user from one part to the next make manually creating and calling startActivity() not only cumbersome, but also buggy.\nInstead, the Android toolkit has a navigational component built-in, which leverages fragments to do the dirty work. Here, we create a single activity but use a fragment container, as explained above, to hop from one fragment to the next. Instead of coding the navigation by hand, we leverage what is called a navigation graph, which is\u0026mdash;again\u0026mdash;XML to describe how fragment x gets replaced by fragment y.\nAs an example, here are two fragments, where fragment 1 contains an action to go to fragment 2:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;navigation xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; app:startDestination=\u0026#34;@id/blankFragment\u0026#34;\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/blankFragment\u0026#34; android:name=\u0026#34;com.example.cashdog.cashdog.BlankFragment\u0026#34; android:label=\u0026#34;fragment_blank\u0026#34; tools:layout=\u0026#34;@layout/fragment_blank\u0026#34; \u0026gt; \u0026lt;action android:id=\u0026#34;@+id/action_blankFragment_to_blankFragment2\u0026#34; app:destination=\u0026#34;@id/blankFragment2\u0026#34; /\u0026gt; \u0026lt;/fragment\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/blankFragment2\u0026#34; android:name=\u0026#34;com.example.cashdog.cashdog.BlankFragment2\u0026#34; android:label=\u0026#34;fragment_blank_fragment2\u0026#34; tools:layout=\u0026#34;@layout/fragment_blank_fragment2\u0026#34; /\u0026gt; \u0026lt;/navigation\u0026gt; These fragments will be placed in a container view in your main activity, which acts as the navigation host: an empty container where destinations are swapped in and out of. Therefore, the main activity XML only needs to contain one element, where all the navigation will take place:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;androidx.fragment.app.FragmentContainerView android:id=\u0026#34;@+id/nav_host_fragment\u0026#34; android:name=\u0026#34;androidx.navigation.fragment.NavHostFragment\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; app:defaultNavHost=\u0026#34;true\u0026#34; app:navGraph=\u0026#34;@navigation/nav_graph\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; Note the app:navGraph property, which points to the first XML file. Do not forget to add the necessary Gradle dependencies, as the navigation components reside in separate library files: see the getting started link from the Android Developers Guide.\nPutting it all together To use navigational components, we so far did the following:\n Add a FragmentContainerView and remove everything else in our single activity. Create a new XML file called nav_graph.xml in the res/navigation directory (rightclick on res -\u0026gt; New -\u0026gt; Android Resource File, choose \u0026ldquo;Navigation\u0026rdquo; as Resource type and remember the name). Add all fragments to the navigation and set the first one as the starting one. Add an \u0026lt;action/\u0026gt; to the first fragment to navigate to the second one.  Now all that is left is executing the action, called action_firstFragment_to_secondFragment, for example on click. Go to your first fragment, which is already view binded, and add the following in onCreateView():\nbinding.btnGoToNext.setOnClickListener { val bundle = bundleOf(\u0026#34;mydata\u0026#34; to data) findNavController().navigate(R.id.action_firstFragment_to_secondFragment, bundle) } Remember to enable the necessary serialization plugins if you want to pass objects through bundles\u0026mdash;otherwise, stick with primitive values. See the intents chapter.\nOn the receiving side, you can pluck out the arguments fairly easily:\ndata = (arguments?.getSerializable(\u0026#34;mydata\u0026#34;) as MySharedData?) ?: MySharedData() if(arguments != null) { object mydata = arguments.getSerializable(\u0026#34;mydata\u0026#34;); if(mydata != null) { data = (MySharedData) mydata; } else { data = new MySharedData(); } } else { data = new MySharedData(); }  Note how the elvis operator (?:) and the optional operator (?.) make things much, much easier in Kotlin, compared to a bunch of ugly if\u0026rsquo;s in Java. And that\u0026rsquo;s it, now we\u0026rsquo;ve connected all the separate pieces together using a navigation graph XML file!\nSee examples/kotlin/FragmentSwitcherWithNavigation in the git repository. Compare the source code to the one without the navigation to see the difference between manually switching fragments and letting the navigation tool do its thing. Remember that these are tiny examples: real-world apps have a bit more than merely two fragments\u0026hellip;\nThere\u0026rsquo;s only one thing left to learn before we can easily tackle a responsive master/detail screen such as the above Mac Mail screenshot: RecyclerViews.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/lang/kotlin-examples/",
	"title": "3. Kotlin Examples/Exercises",
	"tags": [],
	"description": "",
	"content": "All examples can be found in the GitHub repository of this very course, at https://github.com/KULeuven-Diepenbeek/appdev-course/tree/main/examples\nWe\u0026rsquo;ll be using IntelliJ to create simple Kotlin projects, so leave Android Studio closed for the moment. While creating a new project, choose\n A Gradle style project, Enable the Kotlin DSL Build Script, and finally Check Kotlin/JVM (uncheck Java)    New Project settings for Kotlin  Wait for the initial Gradle download/build to finish. Create your Kotlin class/source files in src/main/kotlin. Do not forget creating the correct package structure. See the examples in the above GitHub link.\nThe Kotlin DSL (Domain Specific Language) provides an alternative syntax to the traditional Groovy DSL in Gradle buidlfiles with superious IDE support. This means that every statement in your build script should be valid Kotlin syntax. For more information, inspect to the Software Engineering Skills: Kotlin Gradle files course information page.\n1. Taxi Driving: Basic Kotlin syntax Remember the taxi exercise from INF1 last year? The one in BlueJ that teaches you about object composition?\n Model a taxi company. The company can hire drivers, buy cars, and ultimately, drive clients from an address in point A to point B, to hopefully make some money.\n This is simple enough in Java and teaches you how to:\n Create classes Link classes together (a TaxiFirm holds a reference to one or more Cars and Drivers) Create lists of things (extra) Define methods to call other methods on member variables Think about accessibility, constructors and getters/setters  First, take a look at the java solution. Then, try to do it yourself in the Kotlin JVM. If all else fails, peek at the provided solution.\n2. Walking in JFX: Java interoperability Remember the basic JavaFX exercises from INF1, where we created a smiley or person, virtually walking around on the screen? Those labs acted as a first acquaintance with the JavaFX and Movel-View-Controller concepts. The assignment was as follows:\n Create a custom Region and render a simple person consisting out of multiple rectangles. Create buttons up/down/left/right and implement the click events such that the person moves around on the screen in the correct direction.\n This teaches you how to:\n Adhere to the Model-View-Controller pattern Create an AnchorPane and put stuff onto it using SceneBuilder Catch and implement events in the controller Draw custom things in the view Decouple the model from UI logic  If that doesn\u0026rsquo;t refresh your memory, take a look at the java solution. Then, try to do it yourself in the Kotlin JVM. If all else fails, peek at the provided solution.\nSince this is a JavaFX Gradle application, it cannot be started by pressing the play button: the JavaFX module options should be passed along. We rely on the org.openjfx.javafxplugin for this: see the build.gradle file. To run the application, execute the Gradle task application \u0026ndash; run.\n When you\u0026rsquo;re done, compare your solution with the one provided. The following constructs were modified from the Java version:\n Setters are usually directly accessed. Instead of getChilden().add(x);, you just use children.add(x). An init {} block is needed in the view if you want to call a method in the primary constructor. Resource loading is a bit weird, as we need to grab the java class using MyClass::class.java.getResources(). See MainApp.kt. Note how little code we require (125 lines in total), compared to the java implementation (157 lines). Extending JavaFX classes also automatically calls the (default) constructor: class Main : Application(). Notice the brackets. Also note extends is replaced by a simple semicolon.  There are a lot of things that can go wrong when calling Java from Kotlin. For example, some Kotlin-specific keywords, such as when, can be simply functions in Java. To call these, you need to use backticks. Consult the Kotlin-Java interop guide if you encounter a weird error while calling a native Java method.\nMore Examples More small and large examples can be found in the GitHub repository of this very course, at https://github.com/KULeuven-Diepenbeek/appdev-course/tree/main/examples/kotlin\nOn kotlinlang.org, examples that explore every aspect of the Kotlin language are neatly summarized using their online Playground: https://play.kotlinlang.org/byExample/overview. We strongly recommend you to check these out: they are very short, do not require anything to install, and touch upon every basic but important concept you\u0026rsquo;ll need to master.\nThere are also Koans available https://play.kotlinlang.org/koans/overview that let you get familiar with the Kotlin syntax by training again and again until the syntax has been well-imprinted into your brain.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/extra/links/",
	"title": "3. Links and Tutorials",
	"tags": [],
	"description": "",
	"content": "Tutorials Kotlin-Specific  Exercises: The Official Kotlin Koans and examples The Kotlin docs: basics, ways to learn, what\u0026rsquo;s new, the YouTube channel, \u0026hellip; Live Kotlin coding sessions to be followed on Twitch  Android-Specific  Official Android Developer Guide: thé way to start learning Android development. Android developer MAD skills videos in case you\u0026rsquo;re too lazy to read.  Third party tutorials that can prove to be handy as well:\n CodePath Android Cliffnotes Tutorialspoint.com Android Tutorial Vogella.com Android Development Tutorials  Various  Awesome Android Kotlin Apps \u0026mdash; a curated list on GitHub  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/views/",
	"title": "4. Complex layouts: Nested Views",
	"tags": [],
	"description": "",
	"content": "1. RecyclerViews See also: Android dev guide: create dynamic lists with RecyclerView.\nNow that we know what activities are, how to re-use components using fragments, and how to interact between these systems using intents, we almost know all the basics of Android app development. Remember the Mac Mail App layout, introduced in the fragment chapter?\n  Left: the master screen with navigation. Right: the detail: zoomed in on a single mail.  The left-hand side displays a list users can select: their mails. The right-hand side shows the detail view of a single mail. We know these sections have to be divided into fragments to support big and small resolutions. But we do not yet know how to display a list of things. That\u0026rsquo;s where a RecyclerView comes in. From the Android docs:\n RecyclerView makes it easy to efficiently display large sets of data. You supply the data and define how each item looks, and the RecyclerView library dynamically creates the elements when they\u0026rsquo;re needed. As the name implies, RecyclerView recycles those individual elements. When an item scrolls off the screen, RecyclerView doesn\u0026rsquo;t destroy its view. Instead, RecyclerView reuses the view for new items that have scrolled onscreen. This reuse vastly improves performance, improving your app\u0026rsquo;s responsiveness and reducing power consumption.\n This means we\u0026rsquo;ll design how a single item looks like, supply the data, and the RecyclerView will duplicate these and fill in all the details such as (infinite) scroll handling. We\u0026rsquo;ll need a couple of things to do that:\n A RecyclerView instance, that is just like any other view, a part of your layout. A ViewHolder that represents an individual object, and gets binded to the RecyclerView\u0026rsquo;s data. An Adapter that defines and associates with the data with the ViewHolder.  The recycler view is included via the androidx.recyclerview:recyclerview:1.2.1 dependency.\nLet\u0026rsquo;s try to make a simple TODO app to show how these three things are intertwined.\n  A showcase of a simple RecyclerView: the TODO app. See examples in source!  1. Design your layouts In your activity XML file, we will add three objects: a RecyclerView, which will represent the list, an EditText view and a Button, which can be used to add new TODO items to the list. Remember their IDs. The recyclerview might look like this (constraints omitted for brevity):\n\u0026lt;androidx.recyclerview.widget.RecyclerView android:id=\u0026#34;@+id/rvwTodo\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; /\u0026gt; Besides the activity_main.xml file, we\u0026rsquo;ll need a second XML file to design the layout of a single item in the list. This will get repeated and/or recycled by the RecyclerView class. All we need to do is to add a TextView and a Checkbox\u0026mdash;just like in the screenshot above. The root layout can be a ConstraintLayout, just like any other activity. Give the root a android:layout_height value of only 100dp, otherwise every item will be the size of the entire screen.\n2. Create your model and adapter Next, we\u0026rsquo;ll create a class that extends from RecyclerView.Adapter, and an inner class that represents the view holder. These classes drive our recycler view: they (1) couple the layout XML onto the view, and (2) manage the creation of new holders and binding.\nThree methods have to be overrided: item counting (easy, just redirect to the list size), view holder binding (pry out an item and set view values accordingly), and lastly the creation of the viewholder:\nclass TodoAdapter(val items: List\u0026lt;Todo\u0026gt;) : RecyclerView.Adapter\u0026lt;TodoAdapter.TodoViewHolder\u0026gt;() { inner class TodoViewHolder(currentItemView: View) : RecyclerView.ViewHolder(currentItemView) override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TodoViewHolder { val view = LayoutInflater.from(parent.context).inflate(R.layout.item_todo, parent, false) return TodoViewHolder(view) } override fun onBindViewHolder(holder: TodoViewHolder, position: Int) { state accordingly val currentTodoItem = items[position] holder.itemView.apply { findViewById\u0026lt;TextView\u0026gt;(R.id.txtTodoTitle).text = currentTodoItem.title findViewById\u0026lt;CheckBox\u0026gt;(R.id.chkTodoDone).isChecked = currentTodoItem.isDone } } override fun getItemCount(): Int = items.size }  It is common practice to include an \u0026ldquo;inner class\u0026rdquo;\u0026mdash;just like you would in Java\u0026mdash;as a ViewHolder: the above definition does not have a body. You can move some of the bind logic there or provide custom onClick events for the checkboxes.\n The model, the Todo class, is very simple, holding only a string and a boolean:\ndata class Todo(val title: String, val isDone: Boolean) Note that this means the list the RecyclerView shows is a List\u0026lt;Todo\u0026gt;: it\u0026rsquo;s not list of primitives, it can be anything! The official Android RecyclerView example on GitHub is a \u0026ldquo;flower finder\u0026rdquo; app and shows a list of thumbnails and descriptions.\n3. Initialize your adapter in the main activity For demonstrative purposes, create a sampleTodoItems array list with a few sample Todo item values. Then, we can create an instance of TodoAdapter in onCreate():\nvar adapter = TodoAdapter(sampleTodoItems) binding.rvwTodo.adapter = adapter binding.rvwTodo.layoutManager = LinearLayoutManager(this) We use view binding (see activities) to get hold of the recyclerview, called rvwTodo. The layout manager must be set to arrange our items in the view accordingly. There are three possibilities, see the docs for more information.\nLastly, let\u0026rsquo;s set a click listener on the add button. This simply adds something to the list. However, the adapter should be notified of a data change in order for the view to update:\nbinding.btnAddTodo.setOnClickListener { val newTodoTitle = binding.edtTodo.text.toString() sampleTodoItems.add(Todo(newTodoTitle, false)) adapter.notifyItemInserted(sampleTodoItems.size - 1) } A simpler alternative would be to call adapter.notifyDatasetChanged()\u0026mdash;however, this is much more inefficient as it updates all elements in the list, not only the last added one.\nTo see it all in action, build examples/kotlin/recyclerview from the course repository.\n2. Navigation Drawers Many Android apps contain some form of menu system. In practice, these are, perhaps as you might have expected by now, also separate views, which slide on top of each other. A classic example of this is the navigation drawer from Google\u0026rsquo;s Material Design stack. It contains menu items, defined in a menu XML file, and has a header, which can contain anything, from a simple TextView to a more intricate Fragment:\n  The navigation drawer slided on top of the app. src: android dev.  Key mechanics involved:\n Use a DrawerLayout in the activity where you want the menu to slide in, instead of a regular ConstraintLayout. It should only contain 2 items: an activity/fragment layout and a NavigationView element. Create a separate layout XML file where the drawer header layout resides. For example, as in the above screenshot, it could contain a logo and some text (\u0026ldquo;Android Studio\u0026rdquo;, android.studio@android.com) Create a separate menu XML file where all menu items, icons, and titles reside. Update the activity code to glue it all together.  The navigation drawer component is part of the external androidx.navigation libraries we also used in the fragment navigation chapter: see setting up your environment in the Android Developers Guide.\nLayouting The NavigationView refers to both the menu and the layout XML:\n\u0026lt;com.google.android.material.navigation.NavigationView android:id=\u0026#34;@+id/navView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; app:headerLayout=\u0026#34;@layout/nav_header\u0026#34; app:menu=\u0026#34;@menu/nav_menu\u0026#34; android:layout_gravity=\u0026#34;start\u0026#34; android:fitsSystemWindows=\u0026#34;true\u0026#34; /\u0026gt; While the menu, created in directory app/res/menu, is quite simple:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;menu xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menuPony\u0026#34; android:title=\u0026#34;My Little Pony\u0026#34; /\u0026gt; \u0026lt;/menu\u0026gt; Don\u0026rsquo;t forget to create a separate layout file for the navigation header (in the XML above referenced as @layout/nav_header). Thus, in total, we have altered and/or created three resource files.\nBinding The meat of the work is done though an instance of ActionBarDrawerToggle. This represents the menu icon (a \u0026ldquo;sandwich\u0026rdquo;-style icon) on the top right where the user clicks on in order for the menu drawer to slide in. After creating an instance and adding it to the drawer layout, we call syncState(), which does the dirty work for us.\nLastly, and perhaps most importantly: drawer menu item click listeners, bound through the navigation view setNavigationItemSelectedListener. Putting everything together in our main activity\u0026rsquo;s onCreate():\nmenuBarToggle = ActionBarDrawerToggle(this, binding.drawerLayout, R.string.menu_open, R.string.menu_close) binding.drawerLayout.addDrawerListener(menuBarToggle) menuBarToggle.syncState() supportActionBar?.setDisplayHomeAsUpEnabled(true) binding.navView.setNavigationItemSelectedListener { when (it.itemId) { R.id.menuPony -\u0026gt; doStuff() // ...  } true }  Note that, in Kotlin, the last statement in closure blocks simply acts as a return value. Hence the perhaps weird true statement, where you\u0026rsquo;d expect a Java-like return true;. That also works, of course\u0026mdash;minus the semicolon. Returning false tells the navigation view that the listener failed to catch the event.\n In order for the menu drawer button to change into a \u0026ldquo;back\u0026rdquo; button that will close the drawer, we simply call setDisplayHomeAsUpEnabled() and pass in true.\nTo see it all in action, build examples/kotlin/recyclerviewWithNavDrawer from the course repository. This is an evolution from the earlier example in this chapter, recyclerview.\nLab Exercises Let\u0026rsquo;s finally try to recreate that Mail App.\n First, design the single item view. It should show a title, the first x characters of the mail body, and a date on the top right (see screenshot above). Next, integrate the above RecyclerView patterns to display the mail list view. Run the app to make sure at least the list view works, before continuing. Add an onClick listener to each item which navigates to another activity (or fragment using navigation: your choice). The detail view should again display the title and date, but also the authors, and the full mail body. Again, make sure the above runs fine before continuing. Now extract the RecyclerView into a single fragment using a FrameLayout and the supportFragmentManager. See the fragments chapter. Re-run and test again. Lastly, now that we have extracted a fragment, introducing a navigation drawer is much simpler: replace the constraint layout of the main activity with a DrawerLayout and create a menu system with the following items:  \u0026ldquo;Clear All Mails\u0026rdquo; (clears the recyclerview list) \u0026ldquo;Reset Mails\u0026rdquo; (resets the list to the hardcoded values) \u0026ldquo;Sort Mails\u0026rdquo; (sorts by date, descending)    Just make up hard-coded fake data to test your app, just like we did in the demo TODO app. If you\u0026rsquo;re done with the above exercise, implement a FloatingActionButton to add a new element to the list as a bonus.\nIn case you were wondering: to display both the list and the detail layout, typically, a sliding pane layout is used, also called a two-pane layout. If you create a new project in Android Studio and select the \u0026ldquo;Primary/Detail Flow\u0026rdquo; template, you\u0026rsquo;ll see an example of this.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/extra/project/",
	"title": "4. Project Information",
	"tags": [],
	"description": "",
	"content": "Minimum requirements Every App should at minimum contain the following:\n At least three fragments or activities; At least one data storage/request system; At least one master/detail using a RecyclerView; At least one Intent; At least one menu option; At least one data signal to be used (GPS, Camera, accelerometer, \u0026hellip;); At least one extra feature you can freely choose. For instance:  Authentication through Google\u0026rsquo;s Play Store or Firebase Sharing data between apps using a ContentProvider Etc\u0026hellip; See links for more inspiration on what\u0026rsquo;s possible.    Also remember to adhere to the Android dev best practices mentioned througout this course, such as:\n Responsive design (do not hardcode px but use sp or dp) Unit tests to test and verify your code and app Security by design: think about permissions and privacy in advance Etc\u0026hellip;  Deadlines TODO team formation/checkins/git/\u0026hellip;\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/lang/tdd/",
	"title": "4. Test Driven Development",
	"tags": [],
	"description": "",
	"content": "Learn the whys and the hows of TDD in Software Engineering Skills: TDD.\nKotlin and JUnit 5 When writing tests in Kotlin, pretty much all conventional Java rules apply. Just write the JUnit 5 test as if you were writing a Java test, except that the syntax is Kotlin-specific.\nAn example:\nclass PeriodTests { @Test fun `Given two overlapping periods When overlapsWith is called Then return true`() { val jandec19 = Periode( LocalDate.of(2019, 1, 1), LocalDate.of(2019, 12, 31) ) val maartnov19 = Periode( LocalDate.of(2019, 3, 1), LocalDate.of(2019, 11, 31) ) assertTrue { jandec19.overlapsWith(maartnov19) } } } A note on the imports:\n @Test is the JUnit annotation: import org.junit.jupiter.api.Test assertTrue is a kotlin-specific one, as you can see that a closure block is given as the single argument: import kotlin.test.assertTrue  Typical Java-based test functions are overlapsWithWhenBothPeriodsAreFilledInIsTrue. However, to enhance readability, kotlin allows you to write full sentences as function names using backtics. This is especially handy in test classes, as long as you constrain yourself to a system: for example, Given x When y Then z. Note that sometimes Android Studio will complain about these full-sentence test names for Android projects. In that case, you\u0026rsquo;ll have to revert to Java-style camel case method names.\nTo enable JUnit 5 in your Gradle-enabled Kotlin project, all you have to do is add the following to your build.gradle.kts:\ndependencies { testImplementation(kotlin(\u0026quot;test\u0026quot;)) // testImplementation(\u0026quot;org.hamcrest:hamcrest:2.2\u0026quot;) -\u0026gt; this is optional } tasks.test { useJUnitPlatform() }  If using the Hamcrest API to write assertions, remember that is is a reserved keyword in Kotlin. That is, assertThat(bla, is(such)) in Java does not compile in Kotlin. You can escape the is with a single backtick, or import it as an uppercase Is: import org.hamcrest.CoreMatchers.'is' as Is (use backticks). If writing pure Kotlin, you can also opt to use MockK, a mocking library specifically designed for Kotlin that lets you write assumptions like this: every { car.drive(Direction.NORTH) } returns Outcome.OK. Examples can be found in the demo project.\n Android and TDD In Android development, there are two kinds of unit tests, as explained by Test your app - Android Developer docs:\n Classic unit test classes, residing in src/test/java. These are the unit/integration tests you\u0026rsquo;re used to, similar to the example above. Special instrumented tests, residing in src/androidTest/java. These are special tests that run on the hardware (or on an emulator). That is, they have access to the Instrumentation API giving you access to information such as Context of the app you\u0026rsquo;re testing.  Note that in Android development, JUnit 4 is used, not JUnit 5 (although it is not impossible). Instrumented tests are annotated with @RunWith(AndroidJUnit4::class) from the androidx.test.ext.junit.runners package. As soon as you run an instrumented test, the configured emulator will boot up. A separate .apk will be built containing your instrumented tests which will be executed on the device.\nAs with the typical unit/integration/end2end test pyramid you\u0026rsquo;ve learned in the SES course, the same holds true here: try to write as many unit tests as possible, since bootstrapping the emulator and compiling a separate package is much, much slower! All integration, UI, and end2end tests are considered instrumented tests in the Android architecture.\nLooking for Android testing sample projects? https://github.com/android/testing-samples\nDatabase integration testing After you\u0026rsquo;ve chewed on the data storage chapter and got your feet wet with Android\u0026rsquo;s Room to access SQLite databases, you can try to write a few integration tests which test your queries and persistence layer. These tests are similar to the integration tests present in the SESsy library webapp.\nFor exmaple, to test if something can be persisted:\n@Test fun todoItemCanBePersisted() { val item = Todo(\u0026#34;brush my little pony\u0026#34;, false) dao.insert(arrayListOf(item)) val refreshedItem = dao.query().single() with(refreshedItem) { assertEquals(item.title, title) assertEquals(item.isDone, isDone) assertEquals(1, id) } } Employ the Room.inMemoryDatabaseBuilder to create your Database object. See the todosavestate example in the course repository for a full-fledged example.\nSince databases are part of the 3rd year program and plenty of integration testing happens in the SES course, integration-testing your Room objects is not a part of this course. Nonetheless, do take a look at the example: cross-pollination between software courses facilitates your learning!\nScenario-based UI testing Besides the exposed Context object in instrumented tests, we can also write scenario tests. For web-based programs, we can rely on WebDriver and a Selenium webbrowser plugin to record a specific scenario and verify the visibility and position of UI elements.\nIn Android, the same concepts exist in the form of the Espresso Test Recorder.\nWhich procedures should be instrumented, and which ones should be unit testable? Anything that interacts with signals or hardware should also be instrument-tested at least once. Remember to stub/mock out as much as possible to convert these scenarios into unit tests. Espresso has interesting methods that allow you to stub intents: see this activity test class as an example.\nEspesso allows us to select views, press on buttons, and verify something on-screen:\n@RunWith(AndroidJUnit4::class) class MainActivityTests { @get:Rule val rule = ActivityScenarioRule(MainActivity::class.java) @Before fun setUp() { Intents.init() } @After fun tearDown() { Intents.release() } @Test fun givenCorrectPassword_whenLoginPressed_thenTransitionToWelcome() { onView(withId(R.id.txtPassword)).perform(ViewActions.typeText(\u0026#34;supersecret\u0026#34;), ViewActions.closeSoftKeyboard()) onView(withId(R.id.btnLogin)).perform(ViewActions.click()) Intents.intended(IntentMatchers.hasComponent(WelcomeActivity::class.java.name)) } }  The Espresso activity suite expects a public field for JUnit Rules to apply. Although in Kotlin, properties are public by dfeault, Kotlin\u0026rsquo;s val in fact generates a private field with public getters by default. @get:Rule applies the rule to the field. @JvmField is an alternative way to tell Kotlin to produce a pure backing field.\n See the test in action:\nYour browser does not support HTML video. Here's a link to the MP4-encoded video instead: /vid/espresso.mp4.   Do not forget to add the following test dependencies to your Gradle app module:\ndependencies { testImplementation(\u0026quot;junit:junit:4.+\u0026quot;) androidTestImplementation(\u0026quot;androidx.test.ext:junit:1.1.3\u0026quot;) androidTestImplementation(\u0026quot;androidx.test.espresso:espresso-core:3.4.0\u0026quot;) androidTestImplementation(\u0026quot;androidx.test.espresso:espresso-intents:3.4.0\u0026quot;) } If you created the project using an existing template in Android Studio, only the latter one will be missing. The espresso library version numbers must match! Feel free to fiddle with the Espresso toolset. The course repository has ample examples of these tests: see the loginactivity Kotlin example project, where the above example comes from.\nHowever, this falls beyond the scope of this course.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/data-storage/",
	"title": "5. Data Storage: File/Network",
	"tags": [],
	"description": "",
	"content": "Suppose we\u0026rsquo;d like to store the TODO elements in the example from the nested views chapter. Remember that TODO app, where you could check off several items and add new ones? Every time we reboot that app, our newly added items and checked state\u0026mdash;the data, so to speak\u0026mdash;is gone.\n  The TODO App from the view chapter: how do we save its state?  There are several possibilities to tuck away and re-retrieve the above data:\n It could be part of Android\u0026rsquo;s preferences system: simple key/value pairs accessible through the Activity API: it doens\u0026rsquo;t get any simpler than this. It could be simply written to a file. You should be familiar with JSON serialization, we\u0026rsquo;ve used it in INF1 while getting to know Java with the help of the GSON library from Google. It could be part of sharable Media, usable through the MediaStore API. This allows different apps to share data, but requires extra permissions! It could be stored in a real database. That database could be a simple local SQLite file. The databases course is reserved for the third academic year, but a simplistic example will be handled in this chapter. It could be stored remotely: on another website, accessible only through the internet via for example HTTP GET calls.  In this chapter, we\u0026rsquo;ll see how we store and retrieve data in Android apps.\nCarefully consider which of the data storage solutions is right for you. Do you want your data to be persisted after the user uninstalls your app? Do you want it to be sharable? Do you want other (web)applications to be able to access it? This isn\u0026rsquo;t a case of picking an appealing technology but of picking what is appropriate for the thing you\u0026rsquo;re trying to achieve.\n Before being able to save the TODO items, we need to enable two-way data binding. Until now, the TODO items in the view were synced based on the values in the backend. Go to the Todo adapter, and add a click listener to chkTodoDone. When it is clicked, we want to re-sync the state with the current todo item (in onBindViewHolder()). It needs to go both ways, otherwise we don\u0026rsquo;t have any data to save:\nval checkBoxTodo = findViewById\u0026lt;CheckBox\u0026gt;(R.id.chkTodoDone) checkBoxTodo.isChecked = currentTodoItem.isDone checkBoxTodo.setOnClickListener { currentTodoItem.isDone = checkBoxTodo.isChecked } Also, think about at what point exactly to save and load. Should it be onDestroy()? Somewhere else? Consult the activity/fragment licecycle diagram to determine the best suited event. Remember that some events do NOT get triggered on force closes/crashes/etc. Treat loading as if things were never saved if things go awry: always have backup plan.\n1. Preferences Access There are two kinds of preferences:\n The ones shared by a single activity, accessible through getPreferences() on the activity. The ones shared by your whole app, independent of the view/activity, accessible through getSharedPreferences().  The rest is simple enough:\n// reading val sharedPref = activity?.getSharedPreferences( getString(\u0026#34;key\u0026#34;), Context.MODE_PRIVATE) // writing val sharedPref = activity?.getPreferences(Context.MODE_PRIVATE) ?: return with (sharedPref.edit()) { putString(\u0026#34;key\u0026#34;, \u0026#34;Hi, I\u0026#39;m a value!\u0026#34;) apply() } The value you save can simply be a GSON-ified JSON String representation of an object. Remember the statement gson.toJson(object) that outputs a string? That one.\n2. File Access Private file access is also trivial: grab hold of a FileOutputStream through the context.openFileOutput(fileName, Context.MODE_PRIVATE) context API. These files are not shared between apps, and therefore, no special permissions are needed. Be sure to check for possible exceptions: for instance, FileNotFoundException might occur, or what to do when the file is corrupt? These situations are best handled in a separate class, such as a repository, as also done in the SES course.\nWrite to the output stream as you would in any other Java code: using readObject() and writeObject(). Examples are available in the demo project at examples/kotlin/todosavestate.\n3. Database Access Simple object serialization might do in simple cases, but more intricate apps gravitate towards the use of databases. SQLite, the in-memory or in-file SQL database solution, also works with a single (private) file behind-the-scenes, meaning no additional security measurements are required. The usage of SQLite on Android is simplified thanks to Room, an easy-to-use API part of Android Jetpack. Again, be sure to import the necessary dependencies:\nplugins { id(\u0026quot;kotlin-kapt\u0026quot;) } dependencies { val room_version = \u0026quot;2.3.0\u0026quot; implementation(\u0026quot;androidx.room:room-runtime:$room_version\u0026quot;) implementation(\u0026quot;androidx.room:room-ktx:$room_version\u0026quot;) testImplementation(\u0026quot;androidx.room:room-testing:$room_version\u0026quot;) kapt(\u0026quot;androidx.room:room-compiler:$room_version\u0026quot;) // only for Mac M1 users: kapt(\u0026quot;org.xerial:sqlite-jdbc:3.34.0\u0026quot;) }  Mac M1 users might be greeted with weird build-time exceptions, with underlying caused by No native library is found for os.name=Mac and os.arch=aarch64. In that case, add another kapt dependency: kapt(\u0026quot;org.xerial:sqlite-jdbc:3.34.0\u0026quot;).\n Configuring your objects/Dao To use Room, it suffices to apply a few key annotations on both our Entity (the Model, the object we wish to persist) and on a newly created Dao interface.\n@Entity data class Todo( @ColumnInfo(name = \u0026#34;title\u0026#34;) val title: String, @ColumnInfo(name = \u0026#34;is_done\u0026#34;) var isDone: Boolean, @PrimaryKey(autoGenerate = true) var id: Int = 0) This is indeed very reminiscent of JPA\u0026rsquo;s @Entity annotations, but make no mistake, these are Android Room-specific. Take a look at the 3rd year database course: JPA chapter if you\u0026rsquo;re curious about next year\u0026rsquo;s course contents. If you\u0026rsquo;re fluent with Android\u0026rsquo;s Room and SQLite, you\u0026rsquo;ll have no problem tackling that course.\nNext, create a new interface called TodoDao, where your SQL actions will live:\n@Dao interface TodoDao { @Query(\u0026#34;SELECT * FROM Todo\u0026#34;) fun query(): List\u0026lt;Todo\u0026gt; @Insert fun insert(items: List\u0026lt;Todo\u0026gt;) } An implementation will be generated for you, accessible through a third (abstract!) class we call TodoDatabase:\n@Database(entities = arrayOf(Todo::class), version = 1) abstract class TodoDatabase : RoomDatabase() { abstract fun todoDao() : TodoDao } Kotlin\u0026rsquo;s kapt compiler plugin, which stands for Kotlin Annotation Processor, is responsible for processing the above classes, and generating two implementation files: TodoDao_Impl and TodoDatabase_Impl. The queries that are simply annotated live in there:\n  Generated Room Dao implementations.  If you ever wondered which exact query an annotation such as @Insert without any arguments generates, take a little peek there. It\u0026rsquo;s also possible to log queries as they get executed, but it involves sub-performant hooks. An example can be found in the TodoPersistenceTests unit tests class in the course repository.\nExecuting your repository methods Note that the accessing data using Room DAOs guide states the following:\n Note: Room doesn\u0026rsquo;t support database access on the main thread unless you\u0026rsquo;ve called allowMainThreadQueries() on the builder because it might lock the UI for a long period of time. Asynchronous queries—queries that return instances of LiveData or Flowable—are exempt from this rule because they asynchronously run the query on a background thread when needed.\n This means we can\u0026rsquo;t simply call our find() or insert() queries straight form the activity/fragment. There are multiple solutions to this problem, and since the concept is fairly complex (it involves live data), we went with the simplest one, adding .allowMainThreadQueries() to our database builder.\nThe builder creates an instance of TodoDatabase, on which we can call todoDao() to access the DAO (Data Access Object) implementation to get and store our TODO items:\ndb = Room.databaseBuilder(appContext, TodoDatabase::class.java, \u0026#34;todo-db\u0026#34;) .allowMainThreadQueries() .build() dao = db.todoDao() That\u0026rsquo;s it, now we can call query() and insert() from our activity/fragment! The above appContext which is needed to build the database object is the Application Context of an activity.\nTo correctly unit test and debug your database, please refer to the android developer guide. Since the database requires an application context, it\u0026rsquo;s best to create instrumented tests. See the TDD chapter for more information. Samples are, again, to be found in examples/kotlin/todosavestate in the repository.\nIn case you store sensitive information in your database, consider using SQLCipher to encrypt the database. A Room plugin is available that injects the correct configuration through the database builder objects. See the security by design chapter. This is out of scope for this course.\n4. HTTP Network Access Volley is Android\u0026rsquo;s Go-To HTTP client that comes with advanced caching mechanisms built-in: see the android dev guide on volley. Be prepared to add yet another dependency. To access the internet in our app, we\u0026rsquo;ll have to add the android.permission.INTERNET permission in the app\u0026rsquo;s manifest file.\nLet\u0026rsquo;s try to create a simple GET request and print out the results. In Volley, all requests are put in a queue: HTTP calls are asynchronous! This means we can\u0026rsquo;t simply return results: it needs to be handled in a callback. Welcome to async hell\u0026mdash;those who\u0026rsquo;ve struggled with it in JavaScript will know what to expect.\nval queue = Volley.newRequestQueue(context) val req = StringRequest(Request.Method.GET, \u0026#34;https://www.google.com\u0026#34;, Response.Listener\u0026lt;String\u0026gt; { println(\u0026#34;cool, we\u0026#39;ve got a result: $it\u0026#34;) }, Response.ErrorListener { println(\u0026#34;whoops, something went wrong: ${it.message}\u0026#34;) }) queue.add(req) The two parameters, a response listener and error listener, are anonymous interface implementations with a single method.\nIn most cases, a GET without any header does not suffice. Instead of a StringRequest, you can also create a JSONObjectRequest and pass in a JSONObject as your request body. Fully customized HTTP calls are best handled by implementing your own request object. This allows you to:\n override fun getParams(): Form parameters in case of a x-www-form-urlencoded request override fun getBodyContentType() to specify a custom Content-Type override fun getHeaders() to specify other custom headers  The todosavestate code contains an example of such a custom request object.\nBe warned (again): Volley is asynchronous, meaning \u0026ldquo;return bla\u0026rdquo; on response just won\u0026rsquo;t work. To make things work, you\u0026rsquo;ll have to (1) show a loading widget, (2) fire off the HTTP call by adding it to the queue and (3) do your thing on response, also not forgetting to update the UI. In case of a RecyclerView, that\u0026rsquo;s notifyDataSetChanged(). Watch out with multithreading and changing UI logic!The example shows how you can still pass along a custom response handler object by making use of Kotlin\u0026rsquo;s SAM interfaces.In case of network exceptions, be sure to check the error message. IO procedures are prohibited on the Android Main thread. The demo project shows how to deal with it using Kotlin\u0026rsquo;s coroutines in case you execute synchronous network-related code (optional).\n Volley can be confusing and difficult to use. It\u0026rsquo;s a complimentary library, meaning it can be swapped out at any time in favor for alternatives such as Retrofit. Feel free to do so. The demo project also utilizes Volley.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/extra/demo/",
	"title": "5. Demo Project",
	"tags": [],
	"description": "",
	"content": "How Long To Beat The demo project, residing in the examples/kkotlin/howlongtobeat directory in the source repository, incorporates everything this course has to offer, to give you a taste of what is possible to create within a limited time frame using your newly acquired knowledge. It contains:\n One main activity, MainActivity, controlling the navigation drawer Many segments controlled by a navigation system, including two RecyclerView lists. Permissions for internet and the camera, and an intent system to share information. Data storage through SQLite and Room, plus private file storage for images. Multiple HTTPS API calls to demonstrate the retrieval and processing of data.  What does it do? A (moving) picture says more than a thousand words:\nYour browser does not support HTML video. Here's a link to the MP4-encoded video instead: /vid/hltb.mp4.   In case that still wasn\u0026rsquo;t clear, it:\n \u0026hellip; recognizes Game Boy and Game Boy Color cartridges based on a snapshot you take from your retro games. \u0026hellip; downloads art data and checks on howlongtobeat.com how long it takes for an average player to beat the game. \u0026hellip; saves this information in your personal game database if selected. \u0026hellip; shows some basic statistics on your game completion progress.  How does it work? The cartridge recognition system (logic in GameFinder.kt) is programmed to adhere to the following logic flow:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR Snap{Take snapshot} GV[Google Vision API] LocalDB[Local Cartridge DB] RemoteDB[DuckDuckGo Cartridge Search] HLTB[How Long To Beat API] ResultHLTB Results] Snap -- GV GV -- LocalDB GV -- RemoteDB LocalDB -- HLTB RemoteDB -- HLTB HLTB -- Result  First, the resized camera picture is uploaded to Google\u0026rsquo;s Vision API. You will need your own API key and put it in apikeys.properties, see the README.md file in the repository. Google offers a free trial to its Cloud system.\nNext, the Vision API returns OCR-recognized text from the image. We\u0026rsquo;re interested in the so-called cartridge code on the left of the cart, which starts with DMG- (Dot Matrix Game) if it\u0026rsquo;s an old school Game Boy cart, or with CGB- (Color Game Boy) if it\u0026rsquo;s a Game Boy Color cart.\nFor example, the Wario Land: Super Mario Land 3 cartridge:\n   displays DMG-WJ-USA sideways. This code uniquely identifies the game. Google\u0026rsquo;s Vision API is not smart enough to detect the fancy lettering in the Wario Land logo, sadly.\nNext, based on that code, the app searchers for the matching game title, either in a pre-defined repository (an embedded .csv file based on the database of gekkio.fi), or if it was not found, fires off a DuckDuckGo search to try and interpret its results as a game title. Note that there is no real DuckDuckGo API: the app employs HTML scraping.\nLastly, if a game title could be found, it is fed to howlongtobeat.com\u0026mdash;also using (admittedly a bit advanced) HTML scraping\u0026mdash;to finally return the results in a list for a RecyclerView to display to the user. If at any step something goes wrong, a correct error message is displayed, and the user can retry the whole process.\nSelecting a result from the HLTB results list automatically adds that game to your local database. You can \u0026ldquo;finish\u0026rdquo; the game by checking a checkbox in the game detail screen, meaning it took you x hours to finish. The statistics dialog box shows how long you still have to play to finish your entire collection. Good luck have fun!\nInspecting the source code What to look out for in the source code?\n Try to understand how the unit tests are written. Again, note the difference between Android-instrumented tests, which run more slowly, and genuine unit tests. The mockk framework is used to mock out certain objects in certain tests (see test driven development). Try to identify the information flow as described above. Can you follow its logic and see where one fragment switches to another one? Understanding the general flow of the program is very important! Note the use of interfaces. In case the Google Vision API does not suffice anymore, or the free trail threshold limit has been reached, it\u0026rsquo;s easy to remove it in favor for another OCR-based API, thanks to the ImageRecognizer interface. Furthermore, it simplifies unit testing and separates the view code from the API logic.  Some more advanced concepts of Kotlin/Android, such as suspend and coroutines, which are not part of this course, can be safely ignored. Just remember that when executing IO calls that take longer than a second, it should be done on a separate thread, otherwise the main thread\u0026mdash;and thus, the UI\u0026mdash;becomes blocked! Starting new threads can be done simply by using the Java-specific logic you have learned in the INF1 course. Otherwise, there\u0026rsquo;s always Stack Overflow to help out. Make sure you understand what you adapt into your own project!\nIn case the project fails to compile: did you forget to create a properties file with your API key in it? See the readme and above!\n Dependencies used:\n kotlinx serialization (transfer results between fragments) kotlinx coroutines (async job processing) mockk instead of Mockito (mocking in unit tests) androidx.navigation (navigation) androidx.room (DB persistence) android.volley (HTTP calls) google.api-client (Vision API, 3 dependencies)  Build features used:\n Android View binding Custom build config flags kapt for Room annotation processing serialization for Kotlin-to-Java serialization  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/lang/multiplatform/",
	"title": "5. Multiplatform Mobile dev.",
	"tags": [],
	"description": "",
	"content": " This small Section is completely optional, and not part of the core contents of this course. It showcases other possibilities for mobile app development, broken free from the solitary confinements of Android native code.\n 1. Other Native Solutions Not everyone buys Android-based phones. Apple\u0026rsquo;s iPhone is arguably (much) more popular, and is based on iOS. Developing apps for iOS is a totally different development experience: it requires other tools, another language, and other deployment chains. This is a bad thing: it means you will have to learn to live in both worlds if you intend to release your software on both operating systems!\nDevelopment of iOS apps is done through the Xcode IDE, a proprietary IDE that only runs on MacOS. That\u0026rsquo;s right, you\u0026rsquo;ll need a Mac machine to build and deploy native iOS apps.\nTo program iOS apps in Xcode, you write code in Swift, a programming language created by Apple in 2014 built on top of the LLVM environment. Swift serves as a replacement for Apple\u0026rsquo;s older Objective-C that originated in the eighties. One of its strengths is its flawless interoperability with Objective-C, like Kotlin has with Java. Swift is also statically typed and also uses smart inferred typing. They both are relatively modern languages. A few similarities and differences:\nval immutable = 55 var somevar: Double = 33.0 fun greet(name: String, day: String): String { return \u0026#34;Hello $name, today is $day.\u0026#34; } let immutable = 55 var somevar: Double = 33 func greet(_ name: String,_ day: String) -\u0026gt; String { return \u0026#34;Hello \\(name), today is \\(day).\u0026#34; }  And then there\u0026rsquo;s SwiftUI:\n SwiftUI is a framework to build User Interfaces (UI) for iOS apps. With SwiftUI, you create the UIs of your iOS apps entirely with Swift code, using a novel declarative approach.\n We would have loved to introduce you to the world of iOS development for a single class, but that would mean everyone must have access to Apple hardware.\nStill, if you\u0026rsquo;re serious about app development, the question isn\u0026rsquo;t \u0026ldquo;which language will I learn\u0026rdquo; but \u0026ldquo;which will I learn first\u0026rdquo;. You simply cannot ignore the iPhone market!\n2. Multiplatform Mobile 2.1 The Kotlin Way: KMM To ease the development pains that come from maintaining two different code bases in two different languages, using two different IDEs, Kotlin introduced the KMM, or the Kotlin Multiplatform Mobile system. Get familiar with KMM here.\nIn essence, KMM enables you to write and maintain a shared code base for your domain logic, while it splits the UI logic to both OSes' unique capabilities, written either in Android\u0026rsquo;s Activity/Fragment/Intent system, or using SwiftUI. Your code base will look like this:\nsrc | androidMain | MyActivity.kt | androidTest | commonMain | MyObject.kt | commonTest | iosMain | MySwiftUIWindow.swift | iosTest   The KMM platform: shared Kotlin business logic takes the center.  KMM will scaffold certain Swift files for you: it will generate parts of the Swift code, making it easier for the developer to build a single interface for both OSes. See the make your android application work on iOS tutorial for more in-depth information. KMM\u0026rsquo;s case studies, and especially the Netflix migration blog post are interesting reads.\nYou will still need access to both the Xcode and Android Studio toolchain. Therefore, we will again leave it up to the curious student with access to a Mac to discover KMM\u0026rsquo;s capabilities.\n2.2 The Microsoft way: Xamarin Microsoft developed the freely available Xamarin framework, which is:\n Free. Cross-platform. Open source. An app platform for building Android and iOS apps with .NET and C#\n Using Xamarin, you can develop your apps in C# but still deploy on iOS and Android. It is fully cross-platform, and still builds natively. As the site states, Anything you can do in Objective-C or Java, you can do in C#. Looking a bit further, you will still notice two separate docs pages for iOS and Android, as the namespaces and framework libs differ quite a bit. The language might be the same, but the underlying principles are not. This is in line with what KMM tries to do.\n3. Mobile Web Tools Both leaning on Kotlin/Swift and KMM requires heavy investments. What if you could develop mobile apps in a language you\u0026rsquo;re already familiar with? Many companies opt for a JavaScript-powered solution instead, as they employ web developers that not necessarily need to take the time to learn a new web-based framework. This is a rapidly changing environment, meaning many frameworks came and went:\n React Native (hot and relatively new from Facebook) Apache Cordova (almost considered obsolete now) Ionic Mobile (in case you\u0026rsquo;re tired of React and want things in Vue.js instead) jQuery Mobile (very ancient now)  Web development techniques will be explained in detail in the cloud computing course in the master year.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/signals/",
	"title": "6. Embedded Signals",
	"tags": [],
	"description": "",
	"content": "Smartphones typically come equipped with a lot of hardware trinkets: multiple camera lenses, bio-metric scanners, gyroscopes, light sensors, \u0026hellip; Accessing these in your app might lead to inventive use. We\u0026rsquo;ve already seen in the intents chapter that implicit intents are a good way to let other apps or the Android system itself handle the security issues involved with accessing these embedded signals. Some commonly used systems are even provided for you in the ActivityResultContracts class, such as TakePicture and TakePicturePreview.\nAn overview of sensor documentation is available at the Android Developers docs: Sensors.\nHow to access sensor data 1. Checking for capabilities First off, not all phones are equal. That means you need to identify sensor capabilities before doing anything else! Also, depending on the Android API level, some sensors aren\u0026rsquo;t available, so make sure to check (see this overview table).\nSince a \u0026ldquo;Sensor\u0026rdquo; is quite abstract, and there are many types of sensors available, the Android API offers a general, but direct, abstraction layer in the android.hardware package. Once you\u0026rsquo;ve got a handle to the sensor, it is up to the developer to check values, such as:\n resolution maximumRange power vendor version \u0026hellip;  For instance, in the example below, we first check whether Google\u0026rsquo;s gravity sensor v3 is available. If not, we fall back to a general accelerometer. If not, perhaps an appropriate message to the end user should be displayed:\nsensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager if (sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY) != null) { val availableGravitySensors: List\u0026lt;Sensor\u0026gt; = sensorManager.getSensorList(Sensor.TYPE_GRAVITY) val googlev3Sensor = availableGravitySensors.first { it.vendor.contains(\u0026#34;Google LLC\u0026#34;) \u0026amp;\u0026amp; it.version == 3 } println(googlev3Sensor.maximumRange) } else { val acceleroSensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER) if(acceleroSensor == null) { // message to the user?  return } println(acceleroSensor.maximumRange) } The sensor manager is actually a high-level interface that hides a lot of low-level details, such as kernel drivers that access the hardware itself. The Android app communicates with the framework, which lie on top of the sensor kernel-drivers, which operate the hardware:\n  Source: slideshare.net, Chinmay VS, Sensors on Android  Besides runtime-checking, if publishing to Google Play, you can also prescribe the sensor requirements in the manifest file with a \u0026lt;uses-feature /\u0026gt; tag. See above the Android docs link for more information.\nSensor usage always comes in three steps:\n Get hold of the general SensorManager Check capabilities. If successful, get and use a Sensor instance through the manager.  2. Listening to data Once all is good to go, you can register a listener to the sensor, which requires the implementation of the SensorEventListener interface. It comes with two methods:\n onAccuracyChanged(sensor: Sensor, accuracy: Int) onSensorChanged(event: SensorEvent)  the SensorEvent object contains raw data (via the values property), sometimes up to three: one for each axis.\nRemember to register and unregister the event listener on the right moment. For activities, that would be in the onResume and onPause methods. Take the lifecycles of activities and fragments into account!\n When registering, you need to specify a delay: the sampling rate that, depending on the sensor and your needs, could differ from the default SENSOR_DELAY_NORMAL, which is about 200.000 microseconds:\nsensorManager.registerListener(myListener, mySensor, SensorManager.SENSOR_DELAY_NORMAL) If you would like to try this out in the emulator, be sure to go to the emulator settings, check the virtual sensors tab, and click on \u0026ldquo;more sensors\u0026rdquo;. Then, fiddle with the sliders, and voila: you\u0026rsquo;re triggering onSensorChanged events:\n   See the examples/kotlin/sensors demo project for more information. In the example, pay special attention to the way sensor events are unit tested\u0026mdash;it\u0026rsquo;s a hassle!\nTypes of sensors The Android docs categorizes different existing sensors into the following groups:\n Motion sensors, such as:  Accelerometers: measures acceleration force Gyroscopes: measures force of rotation Gravity sensors: measures force of gravity Step counters: measures the number of steps taken since the last reboot   Position sensors, such as:  Rotation vector component sensors Magnetic fields: measure geomagnetic field strength Orientation sensors: measure angles around x/y/z-axis Proximity: distance from objects in cm   Environment sensors, such as:  Temperature sensors: measures ambient air or device temperature Light sensors: measures illuminance Pressure sensors:measures ambient air pressure Humidity sensors: measures ambient relative humidity    The exact values of the SensorEvent.values vector can be consulted in the Anrdoid docs. Details of usage, such as dimensions, mathematical representations, the calculation of angular speeds, and so forth are also available in the docs. A code sample called the batch step sensor is available on GitHub.\nNot all sensors return three-dimensional raw data. For instance, the light sensor only contains one value: illuminance, expressed in lx.\nGPS: Location Services Getting hold of the location of the user requires special permissions, obviously. Since the GPS system is more heavily used than other sensors, it uses a more high-level, different API.\nRead about using locations on Android here.\nThere are two kinds of \u0026ldquo;location access categories\u0026rdquo;:\n Foreground location: navigation apps, requesting location for GPS data on a picture, etc. Background location: IoT apps that constantly track the location of the device.  Both require different permissions and are accessed in different ways. For brevity, we will leave background location optional and up to the reader to discover.\nForeground location access First, declare permissions in the manifest file, and determine whether or not you are content with COARSE_LOCATION, or you really must need FINE_LOCATION:\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_FINE_LOCATION\u0026#34; /\u0026gt; Then, after checking whether or not GPS is enabled, create a location manager, and register\u0026mdash;again\u0026mdash;an event listener, that implements LocationListener:\nval locationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager if(locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) { // option 1: more complex  locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 5000, 10, myListener) // option 2: only get the last location, a simple one-shot call  val location = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER) } The simplest solution is using getLastKnownLocation. If a GPS_PROVIDER is not present, you can fall back to network triangulation by checking if the provider LocationManager.NETWORK_PROVIDER is enabled.\nThe LocationListener interface has a few methods, of which onLocationChanged(location: Location) is the most interesting, where you can pry out the latitude and longitude from the single argument. Note that this does not give you an address: for that, you\u0026rsquo;ll need to create a Geocoder object, pass in a locale (Locale.getDefault()), and call getFromLocation.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/security/",
	"title": "7. Security By Design",
	"tags": [],
	"description": "",
	"content": "Google\u0026rsquo;s \u0026ldquo;safest mobile platform in the world\u0026rdquo; As the Android Developer guide on security states:\n Our goal is to make Android the safest mobile platform in the world. That\u0026rsquo;s why we consistently invest in technologies that bolster the security of the platform, its apps, and the global Android ecosystem. It\u0026rsquo;s a responsibility we share with you, as developers, to keep users safe and secure.\n Sadly enough, Google itself doesn\u0026rsquo;t quite adhere to its own philosophy, as the Android OS is full of trackers that push personal data into Google\u0026rsquo;s greedy hands. Idle Android phones send data to Google ten times more often than iOS devices to Apple, of which more than 30% is location-related:\n  src: linked article.  Alternatives such as the LineageOS Android Distribution exist, which is a free and open-source operating system for various devices based on the Android mobile platform. That is, anything app you build using the knowledge of this course will run flawlessly on LineageOS.\nHowever, it\u0026rsquo;s not because Google sells our private data that we must do the same. Google\u0026rsquo;s recommended security best practices that make sense are:\n Encrypt your data Communicate securely\u0026mdash;always use HTTPS and SSL if fetching data from the internet Test, test, and test again\u0026mdash;not only applicable to TDD, but to manual testing on different physical devices. Audit third-party libraries\u0026mdash;before mindlessly adding in dependencies in your Gradle file, double-check that (1) you really need it and (2) the library is considered safe to use.  The following are a bit more dubious:\n Detect insecure devices (SafetyNet Attestation)\u0026mdash;This effectively prevents end users from choosing alternative Android-based OSes, such as the aforementioned Lineage. Authenticate users and keys with biometrics\u0026mdash;Relying on biometrics can cause end users to distrust your app. Be the first to know (sent vulnerability disclosures through Google\u0026rsquo;s servers to you)\u0026mdash;Another excuse to outsource vulnerable data.  Encrypting Data See also: Android Developer Guide: security with data.\nUse the androidx.security:security-app-authenticator package to encrypt and decrypt files that aren\u0026rsquo;t private and contain sensitive information. Do NOT use Ciper and SecretKeySpec yourself, but use Android\u0026rsquo;s keystore system instead. This is to prevent other apps or hackers from accessing your private key files.\nDo note that encrypting files is not always needed. Simply write files and shared preferences in MODE_PRIVATE: see the data chapter. This prevents other apps from accessing your data, and makes sure that the stored data gets removes along an uninstall procedure. Sure, the files can still be pried out of the system if you really want to. But preferences are\u0026hellip; well\u0026hellip; preferences. And caching/databases that store already readily-accessible information do not need to be encrypted at all.\nIf you do require database encryption, use SQLCipher in conjunction with Room (see the data storage chapter).\nImplementing Android encryption strategies is not part of this course.\nDo not expose API keys! If your app requires data access to a third party, say a Google API, you\u0026rsquo;ll likely need to get your hands on an API key to be able to use that particular service. These keys are usually passed in the request, either as a GET query parameter (unsecure!) or as a POST header flag. It is very tempting to hard-code these keys, as they are simple strings after all. However, this is very bad practice, as malicious users will easily unzip and decompile your .apk file to pry out that key. There are best practices for securely using API keys.\nFor example, in the demo project, the Google Vision API key is not checked in. It resides in a separate properties file that gets integrated into the build using Gradle:\n// Remember that any piece of Kotlin code can be injected into the build file. val apiKeys = file(\u0026#34;../apikeys.properties\u0026#34;).readLines().map { val keyvalues = it.split(\u0026#34;=\u0026#34;) keyvalues[0] to keyvalues[1] }.toMap() android { // ... (definitions of build types)  buildTypes.forEach { it.buildConfigField(\u0026#34;String\u0026#34;, \u0026#34;GOOGLE_VISION_API_KEY\u0026#34;, apiKeys[\u0026#34;GoogleVisionApiKey\u0026#34;]!!) } } Next, in your code, these \u0026ldquo;build config fields\u0026rdquo; are accessible as static flags through the BuildConfig class, which is generated by Gradle as you build the project. See the build.gradle.kts file for more information. Note that this is but one possibility.\nAsking for Permissions See also: Android Developer Guide: Permissions Overview.\nPerhaps the most important app development principle is permissions, configured in the manifest file. We\u0026rsquo;ve briefly touched upon that in the intents chapter to access the camera API. There exist numerous permission types, and it\u0026rsquo;s always best to explicitly ask for as little permissions as possible. Instead, leverage implicit intents and let another app that already has explicit permissions handle the action for you. For example, instead of asking the user for access to their contacts to create a new contact, start an implicit intent that fires up the contacts app itself that does it for you:\nval intent = Intent(Intent.ACTION_INSERT).apply { type = ContactsContract.Contacts.CONTENT_TYPE } intent.resolveActivity(packageManager)?.run { startActivity(intent) // this won\u0026#39;t be run if the activity does not resolve. } Not all specific actions require user permissions at runtime: declaring them in your manifest might be enough. See this workflow:\n  src: Android docs.  The following major different permission types exist (for a full overview, see the permissions overview docs):\n install-time permissions. These are \u0026ldquo;hard-coded\u0026rdquo; into your app and make if easy for the developer to code: just assume everything has been granted, since the app is installed. However, this is VERY off-putting for end users. Avoid. runtime permissions. In order to execute a certain action, the app might need access to a restricted portion of the device: access to photos, media, camera, etc. These make your life as an app developer harder, since it might be the case that the user denies the request, and the app still has to work. However, this is the better option in context of user experience.  A few more best practices:\n Try to be transparent: make it explicit to the user why a permission is requested. This reminder helps users understand exactly when your app accesses restricted data or performs restricted actions. First try to work with loose permissions: ACCESS_COARSE_LOCATION gives the device\u0026rsquo;s location within a 2 km radius. If that really really really (really) does not suffice, only then, you\u0026rsquo;ll need ACCESS_FINE_LOCATION. Again, make sure you really really (\u0026hellip;) need a permission in the first place. Delegate work to other apps using implicit intents. For example, don\u0026rsquo;t declare a CAMERA permission. Instead, invoke the ACTION_IMAGE_CAPTURE intent. See the examples/kotlin/intents source code. Some Android OSes don\u0026rsquo;t require permissions for opening media. Check the docs and only ask for it if you detect the sdkVersion to be lower than the threshold. See this example: opening documents. Some actions have permissions coupled to them (BLUETOOTH_ADMIN and ACCESS_FINE_LOCATION for Bluetooth functionality), but alternatives exist in the API that don\u0026rsquo;t require a permission, such as device pairing.  Consult the Android Permissions Sample Repository for code samples on how to get started with writing/understanding Android Permissions, besides the already provided examples in this course.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/",
	"title": "Course Contents",
	"tags": [],
	"description": "",
	"content": "    App Development See UHasselt ECTS Sheet\nLast changes for academic year 2020 - 2021.\nCourse notes 1. Android Essentials  The Android Life Cycle: Activities Messaging between activities and apps: Intents Typical (master/detail) layouts and their adapters: Views Data storage: File and Network access Complex layouting: Fragments Embedded Hardware: Signals Security by design  2. Language \u0026amp; Support Tools  The Kotlin Programming language Kotlin Examples Test Driven Development and mobile dev. Multiplatform mobile dev.  3. Extras  Installation guide Common errors FAQ Links and external tutorials Project information Need inspiration? A sample/demo project  Syllabus  Teachers: Coordinating Responsible: prof. dr. Kris Aerts - kris.aerts@kuleuven.be Assistant: Wouter Groeneveld - wouter.groeneveld@kuleuven.be Office: Technologiecentrum Diepenbeek, Groep ACRO, D.0.35.  Good-to-know What you should know before starting this course:\n Knowledge of object-oriented software development. Knowledge of the Java programming language.  What you should have learned after completing this course:\n The ecosystem and life cycle of a mobile (Android-based) app and how to tackle the development. The role of the different components in app development and being able to choose one over the other depending on the context. Basic knowledge of the Kotlin programming language. Basic knowledge of the technical Android API. Unit testability of mobile applications. Basic knowledge of multi-platform possiblities in the app development world. drawing up a project plan/analysis for mobile development projects.  Course planning See the menu to the left. This course is worth 3.0 ECTS points, hence it will be divided into 12 chunks (weeks) of 1.5h contact moments each. Extra coaching sessions will be planned if required.\nThe course lies in the second semester of the second year and has quite a bit of overlap with other software-related courses happening at the same time, specifically Software Engineering Skills (SES). During the SES lessons, we\u0026rsquo;ll get to know design patterns and unit testing, which will also be applied in this very course.\nEvaluation  No formal exam planned. An android-based project which will have to be defended orally to motivate the taken design and implementation decisions. Open questions will be asked to gauge the knowledge level of the student.  More learning material See the section \u0026ldquo;Extra\u0026rdquo; in the menu or in the links above. Each section will contain a \u0026ldquo;More learning material\u0026rdquo; part at the bottom of each page linking to supplemental bits and pieces for the curious student.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]