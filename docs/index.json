[
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/",
	"title": "1. Android Essentials",
	"tags": [],
	"description": "",
	"content": " The Android Life Cycle: Activities Messaging between activities and apps: Intents Complex layouting: Fragments Typical (master/detail) layouts and their adapters: Views Data storage: File and Network access Embedded Hardware: Signals Security by design  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/lang/",
	"title": "2. Language &amp; Support Tools",
	"tags": [],
	"description": "",
	"content": " The Kotlin Programming language: essentials The Kotlin Programming language: advanced techniques Kotlin Examples Test Driven Development and mobile dev. Multiplatform mobile dev.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/extra/",
	"title": "3. Extra info",
	"tags": [],
	"description": "",
	"content": "Extra info  Installation guide Common errors FAQ Links and external tutorials Project information Need inspiration? A sample/demo project  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/extra/install/",
	"title": "1. Installation Guide",
	"tags": [],
	"description": "",
	"content": "1. Downloading Android Studio Go to developer.android.com/studio and download the latest stable release of the Android Studio IDE (green button). It comes with a JDK version to compile the necessary Java/Kotlin files and automatically downloads the correct Gradle version depending on your project file.\nBear in mind that the installation will download the required Google Android Development Kit (SDK), chipping away yet another gigabyte form your download limit.\nRequired IDE disk space: 1.5 GB Required SDK disk space: 3.1 GB Required Gradle Lib disk space (usually in ~/.gradle): 1.4 GB Required Cache disk space (usually in ~/.android): 2.3 GB\nTotaling to about 8.5 GB!! You\u0026rsquo;ve been warned.\nBut I\u0026rsquo;m on a Mac! If you are on a modern Mac with an M1 chipset (AMD64), download the latest preview version via the correct link in the archive page: https://developer.android.com/studio/archive Select the \u0026ldquo;Beta build\u0026rdquo; (called Arctic Fox), not the Canary build. Be mindful of the chipset architecture, otherwise the emulator will not work.\nThe program will be installed in /Applications/Android Studio Preview.app, and the Android SDK will be downloaded in ~/Library/Android. The emulator cache will live in ~/.android.\nBut I\u0026rsquo;m on Linux! A few notes for Linux users:\n Do not boot the IDE as root: emulators will be installed in in /root/android and cannot be found (error message will be something like that). If you get an error \u0026ldquo;permission denied /dev/kvm\u0026quot;: Add your use to the kvm group using the command useradd \u0026lt;username\u0026gt; kvm. See https://developer.android.com/studio/run/emulator-acceleration on how to install the right packages in your distribution. Note that as of June 2021, ia32-libs-multiarch does not exist anymore and is not needed.  2. Starting your first app Building When you\u0026rsquo;re finally done with the download and installation procedure, boot up the IDE again and you should be greeted with a \u0026ldquo;New Project\u0026rdquo; screen. Choose Basic Activity from the Phone and Tablet template, press Next and choose a name/location. Leave language on Kotlin and choose API 26 Android 8.0 (Oreo) for your Minimum SDK (should be selected by default).\nAfter pressing Finish, Android Studio will auto-download the correct Gradle version and dependencies.\n  Selecting a new project  Try to build the project (top right: hammer icon, or from Build menu, or using shortcuts). It will take a while the first time.\nDeploying Try to deploy the project. Your virtual machine will probably not be installed/downloaded yet. Go to the AVD manager (top right, open up the second combobox, or using menu Tools \u0026ndash; AVD Manager).\nChoosing the right API and target for your virtual device is extremely important. Be sure to match your CPU architecture (x64/arm64/\u0026hellip;). Be sure to try and match the API version with the API version in your build.gradle targetSdk/compileSdk/buildToolsVersion to avoid compatibility issues.\n The virtual device will likely have to be downloaded first, usually into ~/.android/avd, where the .ini config file of the emulator also resides.\n  Go to the AVD Manager in the build tool menu button bar  After correctly configuring your virtual device (the resolutions and device type do not matter that much right now), press the Play button again (Run app: CTRL+R). Hopefully, after a while, the emulator will do a cold boot (you should see the Android/Google logo and a home screen), and after that your compiled app will load up.\nFiddling Try to alter a few things here and there to see if recompiling/redeploying works. Try to make yourself familiar with the project structure while you\u0026rsquo;re at it:\n|- app |- build |- libs |- src |- main |- java |- com |- exampletest MainActivity.kt SomeFragment.kt |- res |- drawable someimage.jpg ic_laumcher_background.xml |- layout activity_main.xml content_main.xml somefragment.xml |- menu menu_main.xml |- navigation nav_graph.xml |- values colors.xml strings.xml ... |- mipmap ... AndroidManifest.xml |- test |- java |- com |- exampletest SomeTest.kt |- androidTest |- java |- com |- exampletest ExampleInstrumentedTest.kt build.gradle proguard-rules.pro |- build |- gradle build.gradle gradle.properties settings.gradle local.properties gradlew A few different things to remember:\nGradle The toplevel build.gradle file should not be modified\u0026mdash;changes usually happen in the build.gradle file in your app folder (In Android Studio: \u0026ldquo;Module\u0026rdquo;).\nThe wrapper properties file should point to Gradle 7.x for Android projects.\nFor more information on Gradle, see the Software Engineering Skills: Java Gradle Projects lessons.\nCode In:\n src/main/java, as expected. src/test/java, as epected. These are your unit tests. src/androidTest/java\u0026mdash;woah, what\u0026rsquo;s this? These are android-instrumented specific tests that need to run on the device itself: usually UI-related tests. We\u0026rsquo;ll inspect thsese in the chapter on TDD.  Resources Android\u0026rsquo;s UIs are described instead of coded in accompanied .xml files. These live in app/src/res under subdirs layout, menu and navigation. See the Activities lesson to learn more about these files and their contents.\nFor now, go ahead and open up app/src/res/values/strings.xml. It should contain something like this:\n\u0026lt;resources\u0026gt; \u0026lt;string name=\u0026#34;app_name\u0026#34;\u0026gt;TestApp2\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;action_settings\u0026#34;\u0026gt;Settings\u0026lt;/string\u0026gt; \u0026lt;!-- Strings used for fragments for navigation --\u0026gt; \u0026lt;string name=\u0026#34;first_fragment_label\u0026#34;\u0026gt;First Fragment\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;second_fragment_label\u0026#34;\u0026gt;Second Fragment\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;next\u0026#34;\u0026gt;Next\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;previous\u0026#34;\u0026gt;Previous\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;hello_first_fragment\u0026#34;\u0026gt;Hello first fragment\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;hello_second_fragment\u0026#34;\u0026gt;Hello second fragment. Arg: %1$s\u0026lt;/string\u0026gt; \u0026lt;/resources\u0026gt; The resources can be accessed in the layout XMLs to put labels on buttons and re-use key/values. For example, a button can be defined as \u0026lt;Button ... android:text=\u0026quot;@string/next\u0026quot; .../\u0026gt;, referring to the label \u0026ldquo;Next\u0026rdquo; in the above XML.\nGo ahead and try to change the label of the example button to \u0026ldquo;Hello World!\u0026rdquo;. Go nuts.\nDouble-click on fragment_first.xml or activity_main.xml to see the UI editor. On the top right, you can see \u0026ldquo;Code | Split | Design\u0026rdquo;, to switch XML views, just like SceneBuilder in JavaFX. You do remember that from INF1, right?\nClick on Design and drag in a new ImageView from the Common palette. It will open a dialog called Pick a Resource. Press +, choose \u0026ldquo;Import Drawables\u0026rdquo;, ans select a random image file. Images are also described in XML and fairly complex: for each resolution a new one should be provided in case your app runs on a tablet/big screen/small screen/horizontal/vertical mode, etc. The name does not matter.\n  A nice test image for our test app.  Note that after adding the image, the following code was added in the XML of the fragment:\n\u0026lt;ImageView android:id=\u0026#34;@+id/imageView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:src=\u0026#34;@drawable/_ee2e58a037610e49f7165f1df0087e1\u0026#34; tools:layout_editor_absoluteX=\u0026#34;0dp\u0026#34; tools:layout_editor_absoluteY=\u0026#34;0dp\u0026#34; /\u0026gt; Redeploy your test app to verify if it works in your emulator.\nYay! Crackling fireworks! You\u0026rsquo;ve officially gained the right to proclaim It Works On My Machine.\nGetting to know the IDE Android Studio is part of JetBrains' IDEA development environment. That is, it behaves and functions exactly like its other products:\n CLion for cross-platform C/C++ development, used in the Software Design in C/C++ Course GoLand, the most complete Go-centric IDE IntelliJ IntelliJ, the well-respected Java-centered development environment, used in INF1/Software Engineering Skills  Shortcuts\nSince Android Studio is built on top of IntelliJ\u0026rsquo;s IDEA, the shortcut key keymaps are the same!\nHave a look at the IDEA Reference keymap card\nMore features\nConsult Meeting Android Studio at developer.android.com for a run-down on the User Interface and project structure guide of the IDE. This should be familiar to you, as you have used other JetBrains products in other courses in your engineering trajectory.\nTry to (re-)familiarize yourself with the tool by trying to:\n Quickly access a certain file/method/class Zooming in and out, and switching to presenter mode Auto-completing a code fragment Automatically generating a constructor and getters/setters Navigating to a test method Running unit tests and switching to the tests while navigating the production code Executing specific Gradle tasks Setting breakpoints and walking through these in debug mode \u0026hellip;  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/lang/kotlin/",
	"title": "1. Kotlin programming: Essentials",
	"tags": [],
	"description": "",
	"content": "Why in Kotlin, Yet Another Language? Good question! The answer is multi-faceted:\n1. Because Google Says So Google says you should Develop Android apps with Kotlin. It\u0026rsquo;s their recommended way of doing so. They state:\n Write better Android apps faster with Kotlin. Kotlin is a modern statically typed programming language used by over 60% of professional Android developers that helps boost productivity, developer satisfaction, and code safety.\n Among a slew of listed advantages, they have also created an Android Basics in Kotlin course, where the basics of the Kotlin language is the first hurdle to take.\nThanks to Google\u0026rsquo;s push for Kotlin, open source Android projects on GitHub, GitLab, and friends have boomed, massively switching from Java to Kotlin. It is still possible to write Java-like code and mix in a bit of Kotlin here and there: that is one of the powers of a language on top of the JVM. It would make no sense for us to teach you Android development without touching upon Kotlin, as reading source code of bigger projects would become hard since they\u0026rsquo;re littered with Kotlin-specific syntax.\nTry navigating your way through a few of the following popular open source repositories:\n https://github.com/ccomeaux/boardgamegeek4android \u0026mdash; a BoardGameGeek client for Android https://gitlab.com/AuroraOSS/AuroraStore \u0026mdash; A Google Playstore Client https://github.com/owncloud/android \u0026mdash; The ownCloud Android App https://github.com/mrcsxsiq/Kotlin-Pokedex \u0026mdash; Gotta Catch \u0026lsquo;em All! Pokémon!  Simply search for \u0026ldquo;kotlin\u0026rdquo; and \u0026ldquo;android\u0026rdquo; on GitHub and you\u0026rsquo;ll find yourself wading knee-deep into modern and highly-maintained app source code.\nMoreover, troubleshooting using Google/Stack Overflow usually nets you Kotlin code, as it\u0026rsquo;s become that common. Yet another point in favor for learning Android app development \u0026ldquo;the recommended way\u0026rdquo;. We promise it won\u0026rsquo;t hurt a bit. Maybe only sting. Just a little bit.\n2. Because Kotlin is Java 2.0 Writing Kotlin code on the JVM still means programming on the JVM\u0026mdash;the Java Virtual Machine. That is, in the end, you\u0026rsquo;ll still need a firm grasp of Java if things get awry. The ability to decompile .class files lets you take a peek at what the Kotlin compiler does for us. See advanced Kotlin aspects.\nSoftware developers are slowly integrating parts of Kotlin into existing Java architectures: Kotlin mingles well with existing Java-based solutions. The learning curve, therefore, is flattened: you can choose to gradually migrate towards the new functionalities instead of having to go all out with a big bang.\nHowever, since within this course you\u0026rsquo;ll be creating new projects, we\u0026rsquo;ll opt for an all-in Kotlin solution here. In other courses such as Software Engineering Skills, you can choose to do parts in Kotlin, or everything\u0026mdash;or nothing. We hope you\u0026rsquo;ve come to appreciate the beauty of this relatively new language by then.\n3. Because We Say So The software department of ACRO, the KU Leuven research group at Diepenbeek Campus, focuses on functional languages, of which Kotlin certainly fits the bill. Kotlin\u0026rsquo;s functional mechanics are nowhere near as complex as Prolog or Scala (it is a multi-purpose multi-paradigm language, not a pure functional one such as the aforementioned), and is familiar enough for students who are used to writing programs in Java. Thus, with relative little effort, a new (both for you and for the programming community) language can be learned.\n How does Kotlin fit into the JVM? It\u0026rsquo;s actually very simple: you should treat Kotlin as a separate language that compiles into the same byte code class files as traditional Java .class files. These can be packaged into a .jar like any other Java app, and run using the JVM, that won\u0026rsquo;t even know it started as Kotlin code:\n  Compiling java/kotlin files. src: Kotlin in Action book  The only block that stands out here is the Kotlin runtime that has to be packaged with the application, using the correct arguments when compiling command-line:\nkotlinc hello.kt -include-runtime -d hello.jar The -include-runtime check simply tells the Kotlin compiler to pack along Kotlin\u0026rsquo;s API. That is, utility functions such as print(), that serve as simple wrappers for System.out.println(), need to be packaged in the same jar. That is, the Kotlin \u0026ldquo;runtime\u0026rdquo; (nothing runtime about it) is just a dependency! The above schematic also reveals that interoperability between Java and Kotlin is very easy: they\u0026rsquo;re both (eventually) JVM-class files! So, calling Kotlin from Java or Java from Kotlin is easy as pie.\nThe Kotlin language can also be compiled natively using the LLVM compiler, or compile into JavaScript and run on Node. We will be focusing on Kotlin for the JVM in this course.\n Now you\u0026rsquo;re ready to get your hands dirty!\nA Crash Course in Kotlin Roughly based upon Google\u0026rsquo;s Introduction to Kotlin crash course.\nPlay with Kotlin to get to know the language before focusing on Android specifics. The best way to do this is creating simple Kotlin projects in Intellij (see Kotlin examples) or simply by browsing to https://play.kotlinlang.org/\n1. Variables As mentioned before, Kotlin has many functional aspects to it. For variable declaration, you can pre-set a value, declaring it will never change (it\u0026rsquo;s a constant), or just call it a \u0026ldquo;variable\u0026rdquo;.\nfun main(args: Array\u0026lt;String\u0026gt;) { println(\u0026#34;Hi from Kotlin! the Main fun(ction) can be placed outside a class. Cool!\u0026#34;) var count1: Int = 10 count1++ var count2 := 10 count2++ val count3: Int = 10 count3++ // compile error  val count4 = 10 count4++ // compile error } public class MainClass { public static void main(Stringp[] args) { System.out.println(\u0026#34;Hi from... ugly old... Java? Great... \u0026#34;); var count1 = 10; // this works in JDK9+  count1++; int count2 = 10; count2++; final var count3 = 10; count3++; // compile error  final int count4 = 10; count4++; // compile error  } }  This works just like in JavaScript: let (used to be var) and const.\nvalues cannot be changed: they\u0026rsquo;re values. What else is new? No ;\u0026mdash;finally! Note Kotlin has built-in type inference: specifying := Int is not needed, the compiler knows this since you provide a whole number on the right-hand side of the equation sign.\nTry to use val as much as possible: make verything immutable, unless you absolutely have to use a mutable variable. This is good practice that promotes functional-style programming and prevents making mistakes with, among others, concurrency. Note that val person = Person() means you cannot assign another Person to the person variable, but you can still mutate the reference itself: person.age = 10\u0026mdash;unless the setter is private, that is.\nSpot the new syntax in the next section:\nfun main(args: Array\u0026lt;String\u0026gt;) { var name: String = null // does not compile  name = \u0026#34;Wouter\u0026#34; var nameGood: String? = null nameGood = \u0026#34;Wouter\u0026#34; // We can just as well use standard Java invocations.  System.out.println(\u0026#34;My name is \u0026#34; + nameGood.orEmpty()) // this is simply a Kotlin-wrapper.  println(\u0026#34;My name is \u0026#34; + nameGood?.toLowerCase()) // without if check: use ?.  if(nameGood != null) { println(\u0026#34;My name surely is \u0026#34; + nameGood.toLowerCase()) // with if check: no ? after dot  } } This is called null safety. To assign null, you explicitly have to use the question mark ? sign. orEmpty() returns an empty string if the value it holds is effectively null. This method, or using var?. to access properties, omits needlessly checking with if(...) statements, complicating your codebase, such as the last two statements.\nAll standard JDK API methods are still available to you. Remember that you are still working on a Java-specific Virtual Machine. Thus, System.out.println() is still valid (but can be shortened to prinln(), imported from package kotlin.io), although you have to omit the ; at the end of the statement. So, in essence, you already know how to create threads, access files, \u0026hellip;! This is also very important in Android development, as many system-level Android API methods are still Java.\n 2. Conditionals if() is still if(), including the else. What\u0026rsquo;s more interesting, however, is the possibility of replacing your if-else expressions with a when expression:\nval answerString = when { count == 42 -\u0026gt; \u0026#34;I have the answer.\u0026#34; count \u0026gt; 35 -\u0026gt; \u0026#34;The answer is close.\u0026#34; else -\u0026gt; \u0026#34;The answer eludes me.\u0026#34; } println(answerString) // awkward! Need some kind of wrapper private String cantAssignResultOfSwitchInAVar() { switch(count) { case 42: return \u0026#34;I have the answer.\u0026#34;; case 41: case 40: case 39: // wow, this is awkward! \u0026#34;\u0026gt; 35\u0026#34; is impossible in Java.  case 38: case 37: case 36: return \u0026#34;The answer is close.\u0026#34;; default: return \u0026#34;The answer eludes me.\u0026#34;; } return \u0026#34;\u0026#34;; // awkward. String answerString = cantAssignResultOfSwitchInAVar();  Note that in the example above, the expression seems to be missing. If when is used without brackets, Kotlin will check for Boolean values. when is very powerful in Kotlin, compared to switch in Java, that requires constants. You can when over any string/object instance/whatever:\nval color = Color(RED) when(color) { Color(GREEN) -\u0026gt; print(\u0026#34;its green\u0026#34;) Color(RED) -\u0026gt; print(\u0026#34;its red\u0026#34;) } Color color = new Color(RED); if(color.equals(new Color(GREEN))) { System.out.println(\u0026#34;its green\u0026#34;) } else if(color.equals(new Color(RED))) { System.out.println(\u0026#34;its red\u0026#34;) }  Kotlin uses equality checks behind the scenes, the only possible way to implement it in Java. Take a look at the Java implementation to uncover its details.\nNote that no ternary operator exists (val bla = d == 10 ? \u0026quot;jup\u0026quot; : \u0026quot;nah\u0026quot;), although that can be written in a single-line using Kotlin\u0026rsquo;s if:\nIn Kotlin, if and when constructs are expressions: they hold a value. In Java, they are statements that require code blocks. That means that both constructs can appear on the right-hand side of a variable assignment in one line. Don\u0026rsquo;t let the weird syntax scare you: var max = if(a \u0026gt; b) a else b. This makes the ternary operator redundant.\n 3. Classes and Functions Suppose we\u0026rsquo;d like to represent a pawn and its position. This is the (often painfully long) Java way to do it:\npublic class Pawn { private int x; private int y; public Pawn(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public int getY() { return y; } public void setX(int x) { this.x = x; } public void setY(int y) { this.y = y; } @Override public String toString() { return \u0026#34;(\u0026#34; + x + \u0026#34;,\u0026#34; + y + \u0026#34;)\u0026#34;; } } public class Main { public static void main(Stringp[] args) { Pawn p = new Pawn(1, 2); System.out.println(\u0026#34;p is at (\u0026#34; + p); } } While this is the Kotlin way:\nclass Pawn(theX: Int, theY: Int) { var x = theX private set var y = theY override fun toString(): String { return \u0026#34;($x,$y)\u0026#34; } } fun main(args: Array\u0026lt;String\u0026gt;) { val p = Pawn(1, 2) println(\u0026#34;p is at $p\u0026#34;) } That\u0026rsquo;s a lot shorter! What happened here?\n We create a class with a constructor\u0026mdash;on the same line. class Pawn { ... } would work just as well, but everything between () are constructor arguments. That means we can immediately use them in the assignments of the variables. Properties of the class are by default public! So p.y = 346 would be valid, but to countermeasure this, we set the setter to private. There are no \u0026ldquo;getter\u0026rdquo; and \u0026ldquo;setter\u0026rdquo; methods needed this way! You can still define them if you want using get() { below the variable name, as we did with the setter (that has no body, and thus stays the generated one). Remember to put the main() function outside any class. No separate (static) class needed for that. String interpolation exists in Kotlin. Within double quotes, you can access a variable using the $ prefix.  What is called a secondary constructor can still be made, using the more \u0026ldquo;classic\u0026rdquo; approach:\nclass Pawn { var x = 0 constructor(x: Int) { this.x = x } } However, this is to be avoided if only one constructor is sufficient.\nAs for defining functions, just fun name() {} suffices. Functions are public by default, contrary to Java\u0026rsquo;s package-access! Adding protected/private before fun prevents this.\n Want arguments? fun name(arg1: Type, arg2: Type). Want default arguments? fun name(arg1: Boolean = true) Want varargs? fun name(vararg bools: Boolean) Want a return type? fun name(): Type. (Note that void is Unit in Kotlin) Want to call the function? name(false) Want to name arguments while calling? name(arg1: false)  Single-line functions, called expression bodies, can be simplified from fun hi(): String { return \u0026quot;sup!\u0026quot; } to fun hi(): String = \u0026quot;sup!\u0026quot;. The body is specified after the = symbol, and you\u0026rsquo;ll see these functions often. The last statement will automatically be returned, so return can also be omitted. Expression bodies become very powerful when combined with when: fun hi(): String = when { ... }.  The official Kotlin coding conventions style guide recommends you use expression bodies when the body consists of a single expression (getters/setters come to mind).\n More information about unit-returning functions can be found here.\nSometimes, in Java, you need to quickly create a new subclass or an implementation of an interface, to be able to provide an event listener, for example. The typical syntax for that is very convoluted:\nwindow.addMouseListener(new MouseAdapter() { @Override public void mouseClicked(MouseEvent e) { System.out.println(\u0026#34;Good job, right on target!\u0026#34;); } @Override public void ... // ALL methods of the interface need to be provided! }) In Kotlin, an object is used, which is a \u0026ldquo;temporary class\u0026rdquo; that fits the bill:\nwindow.addMouseListener(object: MouseAdapter() { override fun mouseClicked(e: MouseEvent) { println(\u0026#34;Good job, right on target!\u0026#34;) } }) Note that the override keyword is required here. In Java, it\u0026rsquo;s just an annotation that adds to the documentation. In Kotlin, it\u0026rsquo;s part of the syntax.\nFor more information, see https://kotlinlang.org/docs/object-declarations.html#inheriting-anonymous-objects-from-supertypes\n4. Higher order functions Functions can also be variables. Functions can be created ad-hoc, and be disposed of when no longer needed, as part of the local stack. For instance:\nfun main() { var age = 30 var adder: (Int) -\u0026gt; Int = { x -\u0026gt; x + 1 } age = adder(age) println(\u0026#34;Hello, world!!! I\u0026#39;m currently $ageold\u0026#34;) } Here, adder is again declared using an expression body. Try to get used to it! Functions can be declared within functions within functions within \u0026hellip; Its scope closes the variables around it, meaning you can shield off variables created inside functions from the outside world, but not the other way around. age is visible inside adder, but x is not visible inside main.\nThe above code is easily replicated in JavaScript:\nfunction main() { var age = 30 var adder = function(x) { return x + 1 } age = adder(age) console.log(`Hello, world!!! I\u0026#39;m currently ${age}old`) } But not so easily done in Java, although later JDK versions also introduced (clumsy versions of) lambda\u0026rsquo;s.\nA few more things to remember:\n Inside expression bodies, return is missing, but the result of the last line is returned instead. If a return type is missing, kotlin.Unit is returned, corresponding with void in Java. There\u0026rsquo;s also a Nothing type to dictate a function will always return an exception, such as an assertion.  Functions can return functions or accept functions as arguments. This is handy when recycling logic that sorts, collects, or filters collections. Speaking of\u0026hellip;\n5. Arrays, Collections, Looping Kotlin\u0026rsquo;s Array\u0026lt;\u0026gt; generic class is the same as a [] in Java: it\u0026rsquo;s set in size. In Kotlin, arrays are simply classes: there\u0026rsquo;s no distinction between low-level arrays and high-level collections. However, most of the time, we\u0026rsquo;ll want to use Java\u0026rsquo;s ArrayList\u0026lt;\u0026gt; equivalent. Kotlin also leverages interfaces to hide the collection implementation. You will see MutableList\u0026lt;\u0026gt; often:\nclass Stuff(name: String) { val name = name override fun toString(): String { return name } } class Bag { val items: MutableList\u0026lt;Stuff\u0026gt; = mutableListOf(Stuff(\u0026#34;pen\u0026#34;), Stuff(\u0026#34;apple\u0026#34;)) }  Remember, as soon as you initialize an object and do not want to change it, use val instead of var. The list will grow and shrink in size as things get added and removed, but the reference to items, the list instance itself, will not change. That is, items = ArrayList\u0026lt;Stuff\u0026gt;(), which creates a new empty list, is something we don\u0026rsquo;t want to see somewhere in the code.\n Now that we have a bag of items, how do we print out each one? Add the following function to Bag:\nfun rummageThrough() { // option 1  for(item in items) { println(item) } // option 2  items.forEach { println(it) } // option 3, the closest thing to an ugly ol\u0026#39; for we have  for(x in 0..items.size) { print(items) } } The second function is the functional option where we pass in a closure that prints an item. The only argument is automatically available as it. This is how the forEach function is defined in _Collections.kt:\npublic inline fun \u0026lt;T\u0026gt; Iterable\u0026lt;T\u0026gt;.forEach(action: (T) -\u0026gt; Unit): Unit { for (element in this) action(element) } Hold on there! Where\u0026rsquo;s the argument action in our example? We say items.forEach { and not items.forEach(arg) {. This is a special case: if the last argument is a closure, the block that is attached to the function is the argument itself! This is yet another bit of syntactic sugar to ease the use of passing in functions as arguments.\nNot convinced? This piece of Java code:\n// wrongfully assumes \u0026#34;forEach\u0026#34; exists as a method on the collection public interface ForEachAction { void act(Item i); } items.forEach(new ForEachAction() { @Override public void act(Item i) { System.out.println(i); } }) Is the same as each of the following lines in Kotlin:\n// step 1: still too verbose items.forEach({ i: Item -\u0026gt; println(i) }) // step 2: a lambda expression can be moved out of the paranthesis if it\u0026#39;s the last argument items.forEach() { i: Item -\u0026gt; println(i) } // step 3: the empty parenthesis can also be removed if the lambda is the only argument items.forEach { i: Item -\u0026gt; println(i) } // step 4: parameter type inferred items.forEach { i -\u0026gt; println(i) s} // step 5: use the default parameter name \u0026#34;it\u0026#34; items.forEach { println(it) } The reason the above ForEachAction interface gets covered in a Kotlin lambda without having to refer to the method act at all is that it\u0026rsquo;s an interface with a single method: a functional interface or a Single Action Method (SAM) interface. The JDK and Android API are littered with these interfaces, and you already know many of those: java.lang.Runnable, java.util.Comparator, javax.event.EventhHandler, \u0026hellip; This means it\u0026rsquo;s easy to replace anonymous inner functions with Kotlin lambda\u0026rsquo;s when working with JDK/Android APIs. See the kotlin docs for more information.\nNext to forEach, Kotlin provides The Usual Suspects of functional loop tools, such as:\n .filter {} .reduce {} .sumOf {} .maxOf {} .removeIf {} .replaceAll {} \u0026hellip;  To initialize arrays/lists/whatever, Kotlin provides handy utility methods so that we don\u0026rsquo;t need to do silly plumbing as we\u0026rsquo;re used to do in Java. For instance, in Java, creating an ArrayList and adding stuff using new ArrayList\u0026lt;Bag\u0026gt;() { add(new Bag(\u0026quot;apple\u0026quot;); add... } is sometimes shortened using Arrays.asList(). In Kotlin, we simply rely on mutableListOf(Bag(\u0026quot;apple\u0026quot;)), arrayOf(...), arrayListOf(...), etc. There are no new collections introduced in the language: we simply leverage Java\u0026rsquo;s set. The only new things are the utility wrapper functions that come with the Kotlin runtime library.\nNow that you know the basics of Kotlin, you can start programming in the language and adhere to the structure and style of Java development as you are used to. The more you write Kotlin, the more you will gravitate towards functional-style programming. Advanced techniques shed more light on these. If you\u0026rsquo;re impatient, go ahead and start your first venture into the Android dungeons!Remember, if you\u0026rsquo;re stuck, open up the Kotlin docs and refresh your memory.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/activities/",
	"title": "1. Life Cycle - Activities",
	"tags": [],
	"description": "",
	"content": "What\u0026rsquo;s an activity?  An activity is a single, focused thing that a user can do.\n To put it simply, an activity is a window in your app. Each window should do one thing, such as:\n Let the user login Show a welcome screen Let the user pick something out of a list Show the user detail information of the picked item Let the user modify settings \u0026hellip;    Two example activities.  (Images used on this page sourced from https://franklineduardojimenezgiraldo.gitbooks.io/android-studio/)\nSince a single \u0026ldquo;activity\u0026rdquo;/action/screen/window/whatever-the-name is not going to cut it, multiple activities have to be developed and wired together. This is done using wireframing. A wireframe dictates the flow of the application. The above image represents a welcome screen, and a login screen. It might transition to the login screen after tapping or after three seconds. After pressing \u0026ldquo;Sign Up\u0026rdquo;, it might transition again, to a master/detail screen. The resulting wireframe might look like this:\n  An example wireframe that defines relationships between activities.  Since in many activities, components reappear, they get re-used by splitting an activity into fragments. We\u0026rsquo;ll get to that in the complex layouting - fragments part.\nCreating activities in Android Studio Let\u0026rsquo;s try to create our first activity: login screen. Which components can you identify in the above schematics?\n A \u0026ldquo;Login\u0026rdquo; label or graphic A username text field A password text field A login button A \u0026ldquo;or\u0026rdquo; label A \u0026ldquo;create account\u0026rdquo; button/anchor link  Right. These are simple enough. Create a new project, starting with an Empty Activity under template Phone and Tablet. It\u0026rsquo;ll create a single MainActivity.kt class with the following minimalistic code:\nclass MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } } The activity_main.xml will have a single TextView element with the label \u0026ldquo;Hello World!\u0026rdquo;. Try to bootstrap the project before making any changes to ensure your compiler and emulator are set up correctly.\nThe activity layout itself is described in XML. The root is currently \u0026lt;androidx.constraintlayout.widget.ConstraintLayout/\u0026gt;\u0026quot;. Remember JavaFX\u0026rsquo;s AnchorPane, were you could drop components into using SceneBuilder? This is more or less the same, but the \u0026ldquo;Android way\u0026rdquo;. There are of course multiple Layouts available.\nBrowse through the ConstraintLayout documentation and watch the short introduction video on how to build interfaces with it. It allows for multiple flexible ways to define constraints that dictate the position of the components: relative positioning, margins, centering, circular positioning, chaining, dimension constraining, and so forth. We\u0026rsquo;ll minimize complexity by resorting to the GUI-editor embedded into Android Studio instead of writing too much UI-specific code.\nFiddle with the layout editor to place the six needed components for the login screen.\n Inspect and modify desired properties of components if needed in the right-hand pane of the Design Editor (especially the ID on the top-right):\n  Changing the text property of a TextView.  Without specifying constraints, the components will be re-positioned to (0, ) after publishing to your device. To add constraints, drag the circles to touching edges of the ConstraintLayout, or to other elements present in the activity. This \u0026ldquo;locks\u0026rdquo; the component, allowing it only to move by adhering to the constraints. After setting all constraints, try moving one of the components: others will move along with it due to the constraints.\nAdding actions Once you\u0026rsquo;ve got a login button up and running, it would be nice if it actually did something when pressing it. The easiest way to do that is to use Android View Binding:\n View binding is a feature that allows you to more easily write code that interacts with views. Once view binding is enabled in a module, it generates a binding class for each XML layout file present in that module. An instance of a binding class contains direct references to all views that have an ID in the corresponding layout.\n To enable, simply add the buildFeature in your build.gradle.kts file:\nandroid { ... buildFeatures { viewBinding = true } } After refreshing, every XML layout file will be accompanied by a secretly generated Java file that contains the items to access and attach events to. The name of the binding class is generated by converting the name of the XML file to Pascal case and adding the word \u0026ldquo;Binding\u0026rdquo; to the end. activity_main.xml will thus have an ActivityMainBinding class.\nIn your \u0026ldquo;controller\u0026rdquo; (you do remember the Model-View-Controller pattern, right?) that extends from AppCompatAcitivy, add a lateinit binding field, and refer to it using inflate(). Then, we\u0026rsquo;ll set the content view to that particular binding root. If that is done, we can add events:\nclass MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ActivityMainBinding.inflate(layoutInflater) // warning, this is changed, it used to be R.main.id  setContentView(binding.root) // just to prove things changed  binding.btnLogin.setText(\u0026#34;lol\u0026#34;) } } In JavaFX, this is a bit simpler (at first):\npublic class SomeController { @FXML private BUtton btnLogin; @FXML public void initialize() { btnLogin.setOnClick.... } } Here, we can create fields and auto-wire them. In Android, you have to rely on the generated binding class where the fields are: less messy but one more step needed to take. Remember that the more components you have, the more convoluted your FXML Controller is going to get. This is well-hidden behind the binding object in Android systems.\nWe react to events such as the click (\u0026ldquo;tap\u0026rdquo;) event in the same way as you would do in JavaFX:\nbinding.btnLogin.setOnClickListener { view -\u0026gt; Snackbar.make(view, \u0026#34;Nice, clicked a button\u0026#34;, Snackbar.LENGTH_LONG).setAction(\u0026#34;Action\u0026#34;, null).show() } binding.getLoginButton().setOnClickListener(new OnClickListener() { @Override public void onClick(View var1) { Snackbar.make(view, \u0026#34;Nice, clicked a button\u0026#34;, Snackbar.LENGTH_LONG).setAction(\u0026#34;Action\u0026#34;, null).show(); } })  If you can\u0026rsquo;t make sense of the lambda syntax, take a peek at the conventional Java implementation.\nSnackbar is a fast way to provide periodical feedback that automatically disappears. Ta-daa:\n   What else are possible events you can listen to?\n setOnCapturedPointerListener setOnApplyWindowInsetsListener setOnFocusChangeListener setOnDragListener setOnKeyListener setOnHoverListener \u0026hellip;  Retrieve the password value and check it with some hard-coded value. If not correct, show a warning message using a Snackbar. If the username is empty, also show a warning message.\n  Adding a second Activity What should happen once we\u0026rsquo;re logged in successfully? Take another look at the first image on this page: a welcome screen would be nice.\nCreate a second layout XML file by right-clicking on the res folder (or layout), select New \u0026ndash; Layout Resource File, and name it activity_welcome. You\u0026rsquo;re given the option to change the root element, but another ConstraintLayout is fine, since we\u0026rsquo;re now familiar with the basics of element placing in that particular layout. Go to the design editor and pull in a nice welcome text and a sample image that corresponds to the user\u0026rsquo;s avatar. When you\u0026rsquo;re done with that, create the corresponding controller class called WelcomeActivity.\nNext, we need a piece of code to change the activity to the new one, provided the password is correct. That\u0026rsquo;s done using an Intent, of which we\u0026rsquo;ll see more in the coming chapter. An intent is a way to pass messages from one activity to another, but also to tell one activity it should transition to the other:\nval intent = Intent(this, MyNewActivity::class.java) startActivity(intent) Intent intent = new Intent(this, MyNewActivity.class) startActivity(intent)  Note that ::class.java is the Kotlin way to grab hold of the static .class instance of a class. Run your app and see if it works. Chances are you\u0026rsquo;ll see it crash with the following message in the console:\nE/AndroidRuntime: FATAL EXCEPTION: main Process: be.kuleuven.login, PID: 8457 android.content.ActivityNotFoundException: Unable to find explicit activity class {be.kuleuven.login/be.kuleuven.login.WelcomeActivity}; have you declared this activity in your AndroidManifest.xml? at android.app.Instrumentation.checkStartActivityResult(Instrumentation.java:2065) at android.app.Instrumentation.execStartActivity(Instrumentation.java:1727) at android.app.Activity.startActivityForResult(Activity.java:5320) Whoops. Each activity needs to be defined in the AndroidManifest.xml file where you can specify which one is the \u0026ldquo;main\u0026rdquo; that needs to be boostrapped as your application launches. Add an \u0026lt;activity/\u0026gt; tag there and try to guess the correct properties. Android Studio will auto-complete things for you. Make sure exported is set to true.\nTry again and it should work!\nA note on (text) sizes: in Common Attributes, changing the text size means selecting a unit in sp, not px. What\u0026rsquo;s an sp? To be able to support different pixel densities of different screens, we do not rely on hard-coded pixels but let this be calculated. SP = Scalable Pixels and is used for scaling text. Otherwise, use dp. DP = Density-Independent Pixels. See the andorid multiscreen dev guide for more information on how pixels are effectively calculated. Watch the video to get a better grasp of Android\u0026rsquo;s logical pixel densities. Never use px! The same is true for graphic assets, but to avoid automatic scaling which usually ruins your PNGs, provide at least four different versions: one for each dp \u0026ldquo;bucket\u0026rdquo;: MDPI, HDPI, XHDPI and XXHDPI. Again, see the documentation.\n To learn more about message passing, see messaging: intents.\nThe lifecycle of an activity See Android Developer Guide: Understanding the Activity Lifecycle\nSo far, we have leveraged the onCreate() state to wire together things like events and fetch our binding object. However, an activity has multiple stages to go through, and each of them can be hooked into if desired. onCreatae() just so happens to be the first (obligatory!) callback to implement, next to other five important ones: onStart(), onResume(), onPause(), onStop(), and onDestroy(). Take a look at this schematic to see how they relate to each other:\n  A simplified illustration of the activity lifecycle. Src: android.developer.com  As soon as the user navigates from our main activity to MyNewActivity, the main activity will be paused. Pressing BACK causes onResume() to trigger, while the other activity will be paused. When the second activity was successfully (1) created, (2) started and (3) resumed, the previous one will be stopped. Pressing back results in (1) second paused, (2) main started and (3) resumed, so that (4) second is stopped and ultimately (5) destroyed. Try it yourself!\nImplement all six callbacks on the two activities (see above, section \u0026ldquo;Adding a second Activity\u0026quot;). Print a message (in the console if debugging, or using a simple Toast message) for each one to get a sense of what state the application/activity is in. You\u0026rsquo;ll notice that onResume() is also always called during launch.\n  Saving and restoring UI state Besides obvious uses such as saving draft text in onStop(), knowing about the lifecycle is important because as soon as the user rotates the device or switches into multi-window mode, the current activity is destroyed and restarted. The problem is that any UI state is wiped away, but the user still expects an activity\u0026rsquo;s UI state to be persistent!\nFor each activity you design, think about its implications. What does the user expect when he or she returns to it? Should it be wiped? Yes? No? User expectations ans system behavior should match. The Android Dev Guide states:\n Depending upon the action a user takes, they either expect that activity state to be cleared or the state to be preserved. In some cases the system automatically does what is expected by the user. In other cases the system does the opposite of what the user expects.\n In order to save additional instance data before the rotation transition occurs, override onSaveInstanceState() and put data in the Bundle object:\noverride fun onSaveInstanceState(outState: Bundle) { outState.run { putString(\u0026#34;name\u0026#34;, binding.txtUsername.text.toString()) } super.onSaveInstanceState(outState) } Retrieval is possible in onRestoreInstamceState(), or even in onCreate() if for whatever reason the Android OS decided to destroy your activity and recreate it. Make sure to check the contents of the single argument. isEmpty() is a handy check function.\nThere are a plethora of options for preserving and restoring UI state. See saving states docs: use a viewmodel, use raw instance state such as the example above, or even persistent storage. All options come with their own advantages and disadvantages.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/extra/faq/",
	"title": "2. Common Errors FAQ",
	"tags": [],
	"description": "",
	"content": "1. minSdkVersion mismatch Error:\n \u0026ldquo;Expected minSdkVersion \u0026gt;= 21 but found 1\u0026rdquo;\n Cause: mismatch in build.gradle of android SDK and configured SDK in your emulator.\nSolution: just keep these the same. The error disappeared here after selecting for example 30/30.\n2. Emulator process was killed? Error:\n Emulator: process was killed\n Cause: a hundred different things. Consult the Android Studio error log for more details\u0026mdash;these aren\u0026rsquo;t displayed in the IDE. Either pick Help \u0026ndash; show Log (or show Log in Finder if you\u0026rsquo;re on a Mac), or locate it on the HDD (Mac: ~/Logs/Google/AndroidStudioPreviewX, Win: C:\\Users\\\u0026lt;name\u0026gt;\\.AndroidStudioX\\system\\log)\nFind the process was killed message, and you\u0026rsquo;ll likely see another error that caused that one. For instance:\n Too little disk space. Logged in as root user in Linux. .ini file could not be found. x86 emulator installed on an x64-architecture system Apple M1 silicon-related errors if you did not install the latest preview edition.  3. Virtualization HAXVM-related errors Error:\n Unable to install Intel® HAXM\n Or:\n Your CPU does not support VT-x.\n Or:\n Unfortunately, your computer does not support hardware accelerated virtualization.\n Cause 1: Are you on a Mac M1 and did you install the latest release instead of the preview release? You need to download an Android Virtual Device based on an ARM systems image. This is done automatically in the latest preview edition of Android Studio. See installation guide.\nCause 2: Are you on a 64-bit system but did you install 32-bit emulators or components? Pay careful attention to the processor architecture of the installation and your machine\u0026mdash;these should match!\n4. Invalid Entry CRC while deploying Error:\n Failed to transform material-1.3.0.aar invalid entry CRC expected 0x9797\u0026hellip; but got 0x48546\u0026hellip;.\n Cause: I have no idea, and Google/Stack Overflow doesn\u0026rsquo;t seem to know either. It happens sometimes after building and deploying. The emulator boots, but the app won\u0026rsquo;t load in the emulator.\nSolution: Rebuild. Do not restart the emulator, just leave it open. Simply rebuilding seems to fix this problem.\n5. LifecycleOwners must call register before they are STARTED. Error:\n \u0026hellip; is attempting to register while current state is STARTED. LifecycleOwners must call register before they are STARTED.\n Cause:\nAre you calling registerForActivityResult in onCreate() using a callback of sorts? If so, your fragment/activity is still in STARTED state and should be in CREATED state for this particular intent to receive the results. Usually if you want to receive a camera image.\nSolution: move your listener outside of create scope (e.g. onViewCreated()).\n6. NoActivityResumedException when running instrumented tests Error:\nandroidx.test.espresso.NoActivityResumedException: No activities found. Did you forget to launch the activity by calling getActivity() or startActivitySync or similar? at dalvik.system.VMStack.getThreadStackTrace(Native Method) at java.lang.Thread.getStackTrace(Thread.java:1736) at androidx.test.espresso.base.DefaultFailureHandler.getUserFriendlyError(DefaultFailureHandler.java:12) at androidx.test.espresso.base.DefaultFailureHandler.handle(DefaultFailureHandler.java:7) at androidx.test.espresso.ViewInteraction.waitForAndHandleInteractionResults(ViewInteraction.java:8) at androidx.test.espresso.ViewInteraction.desugaredPerform(ViewInteraction.java:11) at androidx.test.espresso.ViewInteraction.perform(ViewInteraction.java:4) at be.kuleuven.login.MainActivityTests.givenCorrectPassword_whenLoginPressed_thenTransitionToWelcome(MainActivityTests.kt:60) Cause: you forgot to bootstrap an activity in your test using @get:Rule and @Before/@After methods. See the Kotlin/Android TDD chapter for more information.\nSolution: Initialize your activity before making any assumptions!\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/lang/kotlin-advanced/",
	"title": "2. Kotlin programming: Advanced",
	"tags": [],
	"description": "",
	"content": "A closer look at Java/Kotlin interop As seen in the kotlin basics, both languages compile to .class files that the JVM can understand. And since class files can be decompiled by the likes of procyon, let\u0026rsquo;s see what happens when we do that to a bit of Kotlin code, just to deepen our understanding of how Kotlin works in relation to Java.\nSuppose we build a joinToString function to print out a string representation of a collection with separators. Copy the following to a single file called collections.kt:\nfun \u0026lt;T\u0026gt; joinToString(collection: Collection\u0026lt;T\u0026gt;, separator: String = \u0026#34;:\u0026#34;, prefix: String = \u0026#34;[\u0026#34;, suffix: String = \u0026#34;]\u0026#34;): String { val builder = StringBuilder(prefix) for((index, element) in collection.withIndex()) { if(index \u0026gt; 0) builder.append(separator) builder.append(element) } builder.append(suffix) return builder.toString() } data class Person(val name: String, val age: Int) fun main(args: Array\u0026lt;String\u0026gt;) { val someCollection = mapOf(\u0026#34;Jos\u0026#34; to Person(\u0026#34;Jos\u0026#34;, 20), \u0026#34;Lowie\u0026#34; to Person(\u0026#34;Lowie\u0026#34;, 56)) println(joinToString(someCollection.values)) println(joinToString(someCollection.values, \u0026#34;, \u0026#34;, prefix = \u0026#34;(\u0026#34;, suffix = \u0026#34;)\u0026#34;)) } A few things that would be impossible to do in Java;\n Every class should be inside the same-named file. That is, the Person \u0026ldquo;data\u0026rdquo; (does not exist in Java) class should reside in a separate file. Top-level functions do not exist and should be placed in static classes. Default arguments do not exist. Java code is usually heavily overloaded, with a lot of duplication as a consequence. Non-nullable references do not exist in Java. We did not use ?, so the arguments to joinToString cannot be null. The easy-access index/value for loop and withIndex() does not exist in Java. Creating tuples using an infix notation: \u0026quot;Jos\u0026quot; to Person().  Create your own infix notation functions by prepending functions with infix. For example, an expressive way to add two numbers could be infix fun Int.plus(other: Int): Int = this + other. That way, you can write 2 plus 3 instead of 2.plus(3)! See the kotlin docs for more details.\n When building using IntelliJ, the output consists of two files in build/classes, perhaps as expected:\n CollectionsKt.class Person.class  Let\u0026rsquo;s decompile the collections file using java -jar procyon-decompiler.jar path/to/CollectionsKt.class. The output is the following Java code:\n// // Decompiled by Procyon v0.6-prerelease //  package be.kuleuven.adv; import java.util.Map; import kotlin.collections.MapsKt; import kotlin.TuplesKt; import kotlin.Pair; import java.util.Iterator; import kotlin.jvm.internal.Intrinsics; import org.jetbrains.annotations.NotNull; import java.util.Collection; import kotlin.Metadata; @Metadata(mv = { 1, 5, 1 }, k = 2, xi = 48, d1 = { \u0026#34;\\u0000 \\n\\u0000\\n\\u0002\\u0010\\u000e\\n\\u0002\\b\\u0002\\n\\u0002\\u0010\\u001e\\n\\u0002\\b\\u0004\\n\\u0002\\u0010\\u0002\\n\\u0000\\n\\u0002\\u0010\\u0011\\n\\u0002\\b\\u0002\\u001a8\\u0010\\u0000\\u001a\\u00020\\u0001\\\u0026#34;\\u0004\\b\\u0000\\u0010\\u00022\\f\\u0010\\u0003\\u001a\\b\\u0012\\u0004\\u0012\\u0002H\\u00020\\u00042\\b\\b\\u0002\\u0010\\u0005\\u001a\\u00020\\u00012\\b\\b\\u0002\\u0010\\u0006\\u001a\\u00020\\u00012\\b\\b\\u0002\\u0010\\u0007\\u001a\\u00020\\u0001\\u001a\\u0019\\u0010\\b\\u001a\\u00020\\t2\\f\\u0010\\n\\u001a\\b\\u0012\\u0004\\u0012\\u00020\\u00010\\u000b¢\\u0006\\u0002\\u0010\\f¨\\u0006\\r\u0026#34; }, d2 = { \u0026#34;joinToString\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;T\u0026#34;, \u0026#34;collection\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;separator\u0026#34;, \u0026#34;prefix\u0026#34;, \u0026#34;suffix\u0026#34;, \u0026#34;main\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;args\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;([Ljava/lang/String;)V\u0026#34;, \u0026#34;advanced-snippets\u0026#34; }) public final class CollectionsKt { @NotNull public static final \u0026lt;T\u0026gt; String joinToString(@NotNull final Collection\u0026lt;? extends T\u0026gt; collection, @NotNull final String separator, @NotNull final String prefix, @NotNull final String suffix) { Intrinsics.checkNotNullParameter((Object)collection, \u0026#34;collection\u0026#34;); Intrinsics.checkNotNullParameter((Object)separator, \u0026#34;separator\u0026#34;); Intrinsics.checkNotNullParameter((Object)prefix, \u0026#34;prefix\u0026#34;); Intrinsics.checkNotNullParameter((Object)suffix, \u0026#34;suffix\u0026#34;); final StringBuilder builder = new StringBuilder(prefix); final Iterator\u0026lt;? extends T\u0026gt; iterator = collection.iterator(); int n = 0; while (iterator.hasNext()) { final int index = n; ++n; final Object element = iterator.next(); if (index \u0026gt; 0) { builder.append(separator); } builder.append(element); } builder.append(suffix); final String string = builder.toString(); Intrinsics.checkNotNullExpressionValue((Object)string, \u0026#34;builder.toString()\u0026#34;); return string; } public static /* synthetic */ String joinToString$default(final Collection collection, String separator, String prefix, String suffix, final int n, final Object o) { if ((n \u0026amp; 0x2) != 0x0) { separator = \u0026#34;:\u0026#34;; } if ((n \u0026amp; 0x4) != 0x0) { prefix = \u0026#34;[\u0026#34;; } if ((n \u0026amp; 0x8) != 0x0) { suffix = \u0026#34;]\u0026#34;; } return joinToString((Collection\u0026lt;?\u0026gt;)collection, separator, prefix, suffix); } public static final void main(@NotNull final String[] args) { Intrinsics.checkNotNullParameter((Object)args, \u0026#34;args\u0026#34;); final Map someCollection = MapsKt.mapOf(new Pair[] { TuplesKt.to((Object)\u0026#34;Jos\u0026#34;, (Object)new Person(\u0026#34;Jos\u0026#34;, 20)), TuplesKt.to((Object)\u0026#34;Lowie\u0026#34;, (Object)new Person(\u0026#34;Lowie\u0026#34;, 56)) }); System.out.println((Object)joinToString$default(someCollection.values(), null, null, null, 14, null)); System.out.println((Object)joinToString(someCollection.values(), \u0026#34;, \u0026#34;, \u0026#34;(\u0026#34;, \u0026#34;)\u0026#34;)); } } What\u0026rsquo;s interesting here?\n Kotlin generated a class named CollectionsKt to match the filename. All our top-level functions are converted to public static final methods. checkNotNullParameter() is sprinkled around everywhere\u0026mdash;even just before returning values. The fancy for loop has been replaced by a not-so-fancy while(iterator.hasNext()): plain old (ugly) Java code. a second $default method has been generated because we call joinToString() two times using different arguments: once with no defaults provided, once with all provided. Array\u0026lt;String\u0026gt; in our main method is indeed a String[] classic Java array. Default values are filled in if arguments are empty with generated if{} checks. to turns out to be a method in TuplesKt, not a construct of the language! Semicolons are back!  To conclude, we can assume that the Kotlin compiler always spews out fully Java-complaint code in such a way that our classic Java projects seamlessly integrate with the more modern language. The only problem is the import kotlin. statements, where the kotlin runtime jar is required to be in the classpath.\nIf you do not understand the syntax of Kotlin at one point. decompile the class file. Try to compile and decompile some of the provided advanced snippets in the course repository and you\u0026rsquo;ll gain a much better understanding of the inner workings of both Kotlin and Java. We highly recommend you try to do this at least once!\n A class inheritance example Since class files are final by default, you\u0026rsquo;ll need to add the open keyword to classes you\u0026rsquo;d like to extend from.\nSubclassing, getters/setters, equality checks Below is another elaborated example that demonstrates some of Kotlin\u0026rsquo;s inheritance quirks:\npackage be.kuleuven.adv open class Animal() { } interface Plays { fun play() } // without \u0026#34;open\u0026#34; in Animal\u0026#39;s definition, this wouldn\u0026#39;t work // classes are FINAL by default! // \u0026#34;implements\u0026#34; and \u0026#34;extends\u0026#34; are both replaced by a semicolon open class Monkey(val name: String) : Animal(), Plays { lateinit var hobbies: String private set // all paths to all constructors MUST initialize this  // otherwise: Exception in thread \u0026#34;main\u0026#34; kotlin.UninitializedPropertyAccessException: lateinit property hobbies has not been initialized  // since the primary constructor doesn\u0026#39;t do this, we\u0026#39;ll need an \u0026#34;init\u0026#34; block for it instead.  init { hobbies = \u0026#34;Boring myself to death with a rock or perhaps a small bush of grass\u0026#34; } constructor(name: String, hobbies: String) : this(name) { this.hobbies = hobbies } constructor(twinbrother: Monkey): this(twinbrother.name, twinbrother.hobbies) override fun play() { println(\u0026#34;ooh ooh aah aah monkey see monkey do?\u0026#34;) } // Note that since it\u0026#39;s a standard Java equals, the argument can be null  // Note that after calling \u0026#34;is?, the argument automagically is class-casted! Wowza! Check out the decompiled source to see the magic:  /* @Override public boolean equals(@Nullable final Object other) { return other != null \u0026amp;\u0026amp; other instanceof Monkey \u0026amp;\u0026amp; Intrinsics.areEqual((Object)((Monkey)other).name, (Object)this.name) \u0026amp;\u0026amp; Intrinsics.areEqual((Object)((Monkey)other).getHobbies(), (Object)this.getHobbies()); } */ override fun equals(other: Any?): Boolean { if(other == null || other !is Monkey) return false return other.name == name \u0026amp;\u0026amp; other.hobbies == hobbies } } class VeryPrivateMonkey private constructor(): Monkey(\u0026#34;I\u0026#39;d rather not say\u0026#34;) fun main(args: Array\u0026lt;String\u0026gt;) { val george = Monkey(\u0026#34;George\u0026#34;) val jeffrey = Monkey(george) // can\u0026#39;t. there\u0026#39;s a \u0026#34;private\u0026#34; constructor  // Seems easier in Java, isn\u0026#39;t it?  // val anonymous = VeryPrivateMonkey()  george.play() jeffrey.play() println(\u0026#34;Are George and Jeffrey alike? \u0026#34; + (george == jeffrey)) } The above code demonstrates the following concepts:\n Access modifiers, and custom ones in a setter primary and secondary constructors init blocks and late binding on properties the obligatory explicit usage of the keyword override how to implement a basic equals method the Kotlin way how to use that equality check: with == instead of .equals(). The identity/reference check uses three = signs: ===, as in JavaScript.  Interfaces, default implementations, properties Suppose we want to oblige the implementation of a getter of a property, but we\u0026rsquo;re building an interface, not a class. In Kotlin, you can add properties to interfaces: these will generate getProperty() function definitions one has to override:\npackage be.kuleuven.adv // note that these implementations generate four different class files: NameProvider, NickNameProvider, PoshNameProvider, and [FilenameKt] // see build/classes/kotlin  // interfaces can hold properties. There are just getter method definitions // interfaces can hold default implementations. (JDK 8+, this is also legal in Java) interface NameProvider { val name: String val email: String get() { return \u0026#34;$name@hotmail.com\u0026#34; } } // We have to provide the \u0026#34;getName()\u0026#34; method, but we\u0026#39;re simply creating a backing field here class NickNameProvider(override val name: String) : NameProvider // Alternatively, implement the getter. class PoshNameProvider() : NameProvider { override val name: String get() = \u0026#34;Prof. Dr. Genius\u0026#34; } fun main(args: Array\u0026lt;String\u0026gt;) { val myProf = PoshNameProvider() val me = NickNameProvider(\u0026#34;Exterminator 2000\u0026#34;) println(\u0026#34;Reach me at ${me.email}- following a lecture of ${myProf.name}\u0026#34;) } The above code demonstrates the following concepts:\n Properties in interfaces, with custom getters that reference to others if needed. Note that you cannot dictate where to store the value: it\u0026rsquo;s an interface, after all. Implementing that interface and simply using override val in the primary constructor to satisfy the constraints. Implementing the getter yourself manually. Again, class bodies that are empty (class bla {}) are redundant: there are no curly braces used in the definition of NickNameProvider. Again, string interpolation, not limited to a single expression, using curly braces inside double quotes.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/intents/",
	"title": "2. Messaging - Intents",
	"tags": [],
	"description": "",
	"content": "Using intents to start an internal activity What if, instead of showing a generic welcome screen after logging in, we want to personally welcome the user?\nInstead of \u0026ldquo;Welcome, have a nice day\u0026rdquo;, as pictured in:\n  Two example activities from 1.1.  We\u0026rsquo;d like to say \u0026ldquo;Welcome [username]\u0026rdquo;! That is, we want to pass arguments from one activity to the next. We\u0026rsquo;ve already created an intent to start a second activity using Intent(this, MyNewActivity::class.java). After this piece of code, and before calling startActivity(), we can add stuff to the intent which is passed along the new activity:\nval intent = Intent(this, WelcomeActivity::class.java) intent.putExtra(\u0026#34;username\u0026#34;, binding.txtUsername.text.toString()) startActivity(intent) On the receiving side, simply pull out the data using the appropriate get function in the onCreate() function after setting the content view to the correct root binding:\nval username = intent.getStringExtra(\u0026#34;username\u0026#34;) binding.txtWelcome.text = \u0026#34;Welcome, $username\u0026#34; Passing objects through intents Of course, passing in tens of different input fields can get cumbersome. Instead, let\u0026rsquo;s provide a data class that represents the user:\ndata class User(val name: String) public class User { private final String name; public String getName() { return name; } @Override public void toString() { return \u0026#34;[\u0026#34; + name + \u0026#34;]\u0026#34;; } @Override public bool equals(object other) { if(other == null || other !instanceof User) { return false; } User otherUser = (User) other; return name.equals(otherUser.name); } @Override public int hashCode() { return name.hashCode(); } }  Remember that data classes are convenient ways to automatically implement getters/setters/equals/hashcode/tostring. Take a look at the Java code and try not to freak out. It\u0026rsquo;s that ugly.\nUnfortunately, that is not enough. Intents only carry along basic key-value pairs of primitives, meaning our object has to be serialized. There are two options to do this:\n The default Java way: implement Serializable. Use Kotlin native serialization to make things easier here. The Android specific way: implement Parcelable. A \u0026ldquo;parcel\u0026rdquo; is a \u0026ldquo;package\u0026rdquo; that needs to be delivered form one side to the other. Parcels are much more efficient on Android devices than serializable. See the parcelable implementation generator docs on how to enable this in your Kotlin-Android project.  Let\u0026rsquo;s settle with the first option. In order to add @Serializable to your data class, we need to install the kotlinx.serialization plugin. Add the plugin to your plugins block in your module build.gradle.kts (keep the version the same as your Kotlin version!):\nplugins { id(\u0026#34;com.android.application\u0026#34;) id(\u0026#34;kotlin-android\u0026#34;) kotlin(\u0026#34;plugin.serialization\u0026#34;) version \u0026#34;1.5.21\u0026#34; // add this } Then, add an implementation dependency  implementation(\u0026quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.2.2\u0026quot;). Lastly, update your User data class to add the @Serializable annotation that should get imported from the package kotlinx.serialization, and the Java Serializable interface to tell Android-specific methods it\u0026rsquo;s a serializable object:\n@Serializable data class User(val name: String) : Serializable { } Now create a function that returns a new User object based on the viewbinding\u0026rsquo;s values. Then pass the single User instance through the intent using putExtra(). Pull it back out using getSerializableExtra().\nAndroid also supports (two-way) data binding, next to the view binding system introduced in chapter 1.1. This allows designers to directly map properties of models into the layouts, thus avoiding having to access every single property to carry over into an intent or another object. Data binding is not part of this course but feel free to use it instead of view binding, should you wish to do so.\n Can you think of other smart ways to share data between activites?\nThe Parcelize alternative is left as an exercise for the reader.\nUsing intents to start an internal service Besides switching activities as screens within a single app, an intent can also pass messages along a background service that performs operations without a user interface. Services can be launched by creating a JobScheduler instance and passing it to startService() (instead of startActivity()) (see API reference). Why would you want to do that?\n To download a large file in the background without blocking the UI To convert a lot of images in the background To upload data to a back-end server using a HTTP POST \u0026hellip;  Services, and the difference between them and typical Java threads, are explained in detail in the Services overview dev guide.\nThe usage of services is not part of this course.\nUsing intents to interact with other apps Implicit intents When you create an intent to switch to an activity, your own app knows how to handle that intent: it should go to that new activity that also lives within your own app. These are called explicit intents: you specify which application will satisfy the intent by supplying the class name of the activity.\nNext to explicit intents, you can also create implicit intents. What\u0026rsquo;s that? According to the docs:\n Implicit intents do not name a specific component, but instead declare a general action to perform, which allows a component from another app to handle it. For example, if you want to show the user a location on a map, you can use an implicit intent to request that another capable app show a specified location on a map.\n Some useful uses of implicit intents:\n Ask \u0026ldquo;any app\u0026rdquo; to take a picture and return a reference to us Ask \u0026ldquo;any app\u0026rdquo; to browse on a map to a specific location Ask \u0026ldquo;any app\u0026rdquo; to print something Ask \u0026ldquo;any app\u0026rdquo; to dail a number \u0026hellip;  In short, messaging between specific apps requires the creation of implicit intents that you do NOT handle yourself.\nThe code for this is really simple:\nval number = Uri.parse(\u0026#34;tel:011112233\u0026#34;) startActivity(Intent(Intent.ACTION_CALL, number)) Each system-wide known implicit intent is specified with a pre-defined String that can be auto-completed:\n  the Auto-completion lists of possible (implicit) intents.  See the guide to intents for more examples such as opening a map, a webpage, creating an e-mail with attachments, and so forth.\nApplications that are not allowed to make calls will generate a SecurityException while attempting to start the action.CALL intent with the message \u0026ldquo;Permission Denial\u0026rdquo;, stating which specific permission is missing (android.permission.CALL_PHONE in case of calling). Add these in your android manifest file if needed. More on that in the security by design chapter.\n In case no single application knows how to handle your implicit intent, not even your own, startActivity() will throw an ActivityNotFoundException. It would thus be in your best interest to wrap your activity starts with a try block!\nA much better, secure way of coding would be to protect implicit intents with runtime checks. Suppose you want to open the camera and afterwards receive the image URI. The app you want might simply not be there on certain devices, or that the user has restricted profile access. The key idea here is to check something before using it, instead of letting it crash afterwards. That\u0026rsquo;s done via resolveActivity():\nval intent = Intent(Intent.ACTION_CALL, number) if(intent.resolveActivity(applicationContext.packageManager) != null) { startActivity(intent) } else { msg(\u0026#34;doesnt work on your device mate\u0026#34;) } This has known issues in certain Amdroid API versions. A fallback would be to still catch the exception.\nRetrieving the result from intents Let\u0026rsquo;s try to capture a picture. Follow along in the taking photos Android Dev guide. Remember advertise that your app depends on having a camera by adding \u0026lt;uses-feature android:name=\u0026quot;android.hardware.camera\u0026quot; android:required=\u0026quot;true\u0026quot; /\u0026gt; in the manifest file. The intent we\u0026rsquo;re going to use is MediaStore.ACTION_IMAGE_CAPTURE.\nFirst, we need to register an \u0026ldquo;activity result\u0026rdquo; in our onCreate(), because it is only safe to call the method before the activity is in its STARTED state:\nclass MainActivity : AppCompatActivity() { private lateinit var pictureActivityResult: ActivityResultLauncher\u0026lt;Void\u0026gt; // ...  override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // ...  pictureActivityResult = registerForActivityResult(ActivityResultContracts.TakePicturePreview()) { bm: Bitmap -\u0026gt; msg(\u0026#34;bitmap is ${bm.height}high\u0026#34;, binding.root) // do something with the captured image  } } Next, in the onclick listener, after asking/checking for the correct permissions, fire off the result using pictureActivityResult.launch(null).\nNow where exactly do we specify which intent to fire off? That magic is obfuscated inside the TakePicturePreview class we\u0026rsquo;re instantiating. You can provide your own what is called activity contracts, but a lot of commons are provided for you in the ActivityResultcontracts class. The picture preview source code looks like this:\npublic static class TakePicturePreview extends ActivityResultContract\u0026lt;Void, Bitmap\u0026gt; { @CallSuper @NonNull @Override public Intent createIntent(@NonNull Context context, @Nullable Void input) { return new Intent(MediaStore.ACTION_IMAGE_CAPTURE); } @Nullable @Override public final SynchronousResult\u0026lt;Bitmap\u0026gt; getSynchronousResult(@NonNull Context context, @Nullable Void input) { return null; } @Nullable @Override public final Bitmap parseResult(int resultCode, @Nullable Intent intent) { if (intent == null || resultCode != Activity.RESULT_OK) return null; return intent.getParcelableExtra(\u0026#34;data\u0026#34;); } } Aha, now we\u0026rsquo;re getting somewhere! Upon further inspection, TakePicture (not the preview one) puts extra data into the intent to capture the whole output. Note the first generic type of the extended class: Void. So that is where that Void comes from in or lateinit var pictureActivityResult: other embedded activity result contracts will likely have other result types (OpenDocument has String[], for instance).\nThese details are provided for you, make use of them.\nYou\u0026rsquo;ll learn the most while digging through the source code of the API itself while hacking your way through the code\u0026mdash;and not by just reading this page. Do not be afraid to press CTRL+B (Go To Declaration) in Android Studio! If you still have no idea what\u0026rsquo;s going on, then developer.android.com is your best friend.\n Delivering/receiving a broadcast Instead of keeping intents as messages within your application, you can also broadcast them so that any app can receive them. The system delivers various broadcasts for system events, such as on bootup or when the device starts charging. Sending broadcasts can be done through sendBroadcast().\nTODO in or out? what about them?\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/fragments/",
	"title": "3. Complex layouting - Fragments",
	"tags": [],
	"description": "",
	"content": "What\u0026rsquo;s a fragment? Extend from Fragment from package androidx.fragment.app.\nUses: reusability   src: componentdriven.org  Uses: easing navigation https://developer.android.com/guide/navigation/navigation-getting-started\nNavigation using fragments\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/lang/kotlin-examples/",
	"title": "3. Kotlin Examples/Exercises",
	"tags": [],
	"description": "",
	"content": "All examples can be found in the GitHub repository of this very course, at https://github.com/KULeuven-Diepenbeek/appdev-course/tree/main/examples\nWe\u0026rsquo;ll be using IntelliJ to create simple Kotlin projects, so leave Android Studio closed for the moment. While creating a new project, choose\n A Gradle style project, Enable the Kotlin DSL Build Script, and finally Check Kotlin/JVM (uncheck Java)    New Project settings for Kotlin  Wait for the initial Gradle download/build to finish. Create your Kotlin class/source files in src/main/kotlin. Do not forget creating the correct package structure. See the examples in the above GitHub link.\nThe Kotlin DSL (Domain Specific Language) provides an alternative syntax to the traditional Groovy DSL in Gradle buidlfiles with superious IDE support. This means that every statement in your build script should be valid Kotlin syntax. For more information, inspect to the Software Engineering Skills: Kotlin Gradle files course information page.\n1. Taxi Driving: Basic Kotlin syntax Remember the taxi exercise from INF1 last year? The one in BlueJ that teaches you about object composition?\n Model a taxi company. The company can hire drivers, buy cars, and ultimately, drive clients from an address in point A to point B, to hopefully make some money.\n This is simple enough in Java and teaches you how to:\n Create classes Link classes together (a TaxiFirm holds a reference to one or more Cars and Drivers) Create lists of things (extra) Define methods to call other methods on member variables Think about accessibility, constructors and getters/setters  First, take a look at the java solution. Then, try to do it yourself in the Kotlin JVM. If all else fails, peek at the provided solution.\n2. Walking in JFX: Java interoperability Remember the basic JavaFX exercises from INF1, where we created a smiley or person, virtually walking around on the screen? Those labs acted as a first acquaintance with the JavaFX and Movel-View-Controller concepts. The assignment was as follows:\n Create a custom Region and render a simple person consisting out of multiple rectangles. Create buttons up/down/left/right and implement the click events such that the person moves around on the screen in the correct direction.\n This teaches you how to:\n Adhere to the Model-View-Controller pattern Create an AnchorPane and put stuff onto it using SceneBuilder Catch and implement events in the controller Draw custom things in the view Decouple the model from UI logic  If that doesn\u0026rsquo;t refresh your memory, take a look at the java solution. Then, try to do it yourself in the Kotlin JVM. If all else fails, peek at the provided solution.\nSince this is a JavaFX Gradle application, it cannot be started by pressing the play button: the JavaFX module options should be passed along. We rely on the org.openjfx.javafxplugin for this: see the build.gradle file. To run the application, execute the Gradle task application \u0026ndash; run.\n When you\u0026rsquo;re done, compare your solution with the one provided. The following constructs were modified from the Java version:\n Setters are usually directly accessed. Instead of getChilden().add(x);, you just use children.add(x). An init {} block is needed in the view if you want to call a method in the primary constructor. Resource loading is a bit weird, as we need to grab the java class using MyClass::class.java.getResources(). See MainApp.kt. Note how little code we require (125 lines in total), compared to the java implementation (157 lines). Extending JavaFX classes also automatically calls the (default) constructor: class Main : Application(). Notice the brackets. Also note extends is replaced by a simple semicolon.  There are a lot of things that can go wrong when calling Java from Kotlin. For example, some Kotlin-specific keywords, such as when, can be simply functions in Java. To call these, you need to use backticks. Consult the Kotlin-Java interop guide if you encounter a weird error while calling a native Java method.\nMore Examples More small and large examples can be found in the GitHub repository of this very course, at https://github.com/KULeuven-Diepenbeek/appdev-course/tree/main/examples/kotlin\nOn kotlinlang.org, examples that explore every aspect of the Kotlin language are neatly summarized using their online Playground: https://play.kotlinlang.org/byExample/overview. We strongly recommend you to check these out: they are very short, do not require anything to install, and touch upon every basic but important concept you\u0026rsquo;ll need to master.\nThere are also Koans available https://play.kotlinlang.org/koans/overview that let you get familiar with the Kotlin syntax by training again and again until the syntax has been well-imprinted into your brain.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/extra/links/",
	"title": "3. Links and Tutorials",
	"tags": [],
	"description": "",
	"content": "Tutorials Kotlin-Specific  Exercises: The Official Kotlin Koans and examples The Kotlin docs: basics, ways to learn, what\u0026rsquo;s new, the YouTube channel, \u0026hellip; Live Kotlin coding sessions to be followed on Twitch  Android-Specific  Official Android Developer Guide: thé way to start learning Android development. Android developer MAD skills videos in case you\u0026rsquo;re too lazy to read.  Third party tutorials that can prove to be handy as well:\n CodePath Android Cliffnotes Tutorialspoint.com Android Tutorial Vogella.com Android Development Tutorials  Various  Awesome Android Kotlin Apps \u0026mdash; a curated list on GitHub  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/views/",
	"title": "4. Layouts - Views",
	"tags": [],
	"description": "",
	"content": "Responsive design TODO geen px maar sd\nRecyclerView Storing and saving states TODO https://developer.android.com/topic/libraries/architecture/saving-states\npressing back, rotating, data gone?\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/extra/project/",
	"title": "4. Project Information",
	"tags": [],
	"description": "",
	"content": "Minimum requirements Every App should at minimum contain the following:\n Three activities: 1 master, 1 detail, 1 config screen One data request + parsing (HTTP GET Request) Use a RecyclerView Use at least one Intent Have a Menu with at least one option Use responsive design (do not hardcode px but use sp or dp) Use Fragments to vary the interface between landscape/portrait mode Use a data signal (GPS, Camera, accelerometer, \u0026hellip;) 9 Contain at least one extra feature you can freely choose. For instance, data storage through SQLite/Firebase/Room, authentication through Google/Firebase/email-pwd, sharing data using a ContentProvider, etc\u0026hellip; See links for more inspiration on what\u0026rsquo;s possible.  Deadlines TODO team formation/checkins/git/\u0026hellip;\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/lang/tdd/",
	"title": "4. Test Driven Development",
	"tags": [],
	"description": "",
	"content": "Learn the whys and the hows of TDD in Software Engineering Skills: TDD.\nKotlin and JUnit 5 When writing tests in Kotlin, pretty much all conventional Java rules apply. Just write the JUnit 5 test as if you were writing a Java test, except that the syntax is Kotlin-specific.\nAn example:\nclass PeriodTests { @Test fun `Given two overlapping periods When overlapsWith is called Then return true`() { val jandec19 = Periode( LocalDate.of(2019, 1, 1), LocalDate.of(2019, 12, 31) ) val maartnov19 = Periode( LocalDate.of(2019, 3, 1), LocalDate.of(2019, 11, 31) ) assertTrue { jandec19.overlapsWith(maartnov19) } } } A note on the imports:\n @Test is the JUnit annotation: import org.junit.jupiter.api.Test assertTrue is a kotlin-specific one, as you can see that a closure block is given as the single argument: import kotlin.test.assertTrue  Typical Java-based test functions are overlapsWithWhenBothPeriodsAreFilledInIsTrue. However, to enhance readability, kotlin allows you to write full sentences as function names using backtics. This is especially handy in test classes, as long as you constrain yourself to a system: for example, Given x When y Then z. Note that sometimes Android Studio will complain about these full-sentence test names for Android projects. In that case, you\u0026rsquo;ll have to revert to Java-style camel case method names.\nTo enable JUnit 5 in your Gradle-enabled Kotlin project, all you have to do is add the following to your build.gradle.kts:\ndependencies { testImplementation(kotlin(\u0026quot;test\u0026quot;)) // testImplementation(\u0026quot;org.hamcrest:hamcrest:2.2\u0026quot;) -\u0026gt; this is optional } tasks.test { useJUnitPlatform() }  If using the Hamcrest API to write assertions, remember that is is a reserved keyword in Kotlin. That is, assertThat(bla, is(such)) in Java does not compile in Kotlin. You can escape the is with a single backtick, or import it as an uppercase Is: import org.hamcrest.CoreMatchers.'is' as Is (use backticks).\n Android and TDD In Android development, there are two kinds of unit tests, as explained by Test your app - Android Developer docs:\n Classic unit test classes, residing in src/test/java. These are the unit/integration tests you\u0026rsquo;re used to, similar to the example above. Special instrumented tests, residing in src/androidTest/java. These are special tests that run on the hardware (or on an emulator). That is, they have access to the Instrumentation API giving you access to information such as Context of the app you\u0026rsquo;re testing.  Note that in Android development, JUnit 4 is used, not JUnit 5 (although it is not impossible). Instrumented tests are annotated with @RunWith(AndroidJUnit4::class) from the androidx.test.ext.junit.runners package. As soon as you run an instrumented test, the configured emulator will boot up. A separate .apk will be built containing your instrumented tests which will be executed on the device.\nAs with the typical unit/integration/end2end test pyramid you\u0026rsquo;ve learned in the SES course, the same holds true here: try to write as many unit tests as possible, since bootstrapping the emulator and compiling a separate package is much, much slower! All integration, UI, and end2end tests are considered instrumented tests in the Android architecture.\nLooking for Android testing sample projects? https://github.com/android/testing-samples\nScenario-based UI testing Besides the exposed Context object in instrumented tests, we can also write scenario tests. For web-based programs, we can rely on WebDriver and a Selenium webbrowser plugin to record a specific scenario and verify the visibility and position of UI elements.\nIn Android, the same concepts exist in the form of the Espresso Test Recorder.\nWhich procedures should be instrumented, and which ones should be unit testable? Anything that interacts with signals or hardware should also be instrument-tested at least once. Remember to stub/mock out as much as possible to convert these scenarios into unit tests. Espresso has interesting methods that allow you to stub intents: see this activity test class as an example.\nEspesso allows us to select views, press on buttons, and verify something on-screen:\n@RunWith(AndroidJUnit4::class) class MainActivityTests { @get:Rule val rule = ActivityScenarioRule(MainActivity::class.java) @Before fun setUp() { Intents.init() } @After fun tearDown() { Intents.release() } @Test fun givenCorrectPassword_whenLoginPressed_thenTransitionToWelcome() { onView(withId(R.id.txtPassword)).perform(ViewActions.typeText(\u0026#34;supersecret\u0026#34;), ViewActions.closeSoftKeyboard()) onView(withId(R.id.btnLogin)).perform(ViewActions.click()) Intents.intended(IntentMatchers.hasComponent(WelcomeActivity::class.java.name)) } }  The Espresso activity suite expects a public field for JUnit Rules to apply. Although in Kotlin, properties are public by dfeault, Kotlin\u0026rsquo;s val in fact generates a private field with public getters by default. @get:Rule applies the rule to the field. @JvmField is an alternative way to tell Kotlin to produce a pure backing field.\n See the test in action:\nYour browser does not support HTML video. Here's a link to the MP4-encoded video instead: /vid/espresso.mp4.   Do not forget to add the following test dependencies to your Gradle app module:\ndependencies { testImplementation(\u0026quot;junit:junit:4.+\u0026quot;) androidTestImplementation(\u0026quot;androidx.test.ext:junit:1.1.3\u0026quot;) androidTestImplementation(\u0026quot;androidx.test.espresso:espresso-core:3.4.0\u0026quot;) androidTestImplementation(\u0026quot;androidx.test.espresso:espresso-intents:3.4.0\u0026quot;) } If you created the project using an existing template in Android Studio, only the latter one will be missing. The espresso library version numbers must match! Feel free to fiddle with the Espresso toolset. The course repository has ample examples of these tests: see the loginactivity Kotlin example project, where the above example comes from.\nHowever, this falls beyond the scope of this course.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/data-storage/",
	"title": "5. Data Storage - File/Network",
	"tags": [],
	"description": "",
	"content": "http client? https://square.github.io/retrofit/\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/extra/demo/",
	"title": "5. Demo Project",
	"tags": [],
	"description": "",
	"content": "TODO howlongtobeat achtig iets?\n Een Java-only en een Kotlin-only app? Een multiplatform gebaseerd op Kotlin\u0026rsquo;s platform? Een React-native gelijkaardige?  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/lang/multiplatform/",
	"title": "5. Multiplatform Mobile dev.",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/signals/",
	"title": "6. Embedded Signals",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/android/security/",
	"title": "7. Security By Design",
	"tags": [],
	"description": "",
	"content": "Android dev and Permissions https://developer.android.com/guide/topics/permissions/overview\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/",
	"title": "Course Contents",
	"tags": [],
	"description": "",
	"content": "    App Development See UHasselt ECTS Sheet\nLast changes for academic year 2020 - 2021.\nCourse notes 1. Android Essentials  The Android Life Cycle: Activities Messaging between activities and apps: Intents Typical (master/detail) layouts and their adapters: Views Data storage: File and Network access Complex layouting: Fragments Embedded Hardware: Signals Security by design  2. Language \u0026amp; Support Tools  The Kotlin Programming language Kotlin Examples Test Driven Development and mobile dev. Multiplatform mobile dev.  3. Extras  Installation guide Common errors FAQ Links and external tutorials Project information Need inspiration? A sample/demo project  Syllabus  Teachers: Coordinating Responsible: prof. dr. Kris Aerts - kris.aerts@kuleuven.be Assistant: Wouter Groeneveld - wouter.groeneveld@kuleuven.be Office: Technologiecentrum Diepenbeek, Groep ACRO, D.0.35.  Good-to-know What you should know before starting this course:\n Knowledge of object-oriented software development. Knowledge of the Java programming language.  What you should have learned after completing this course:\n The ecosystem and life cycle of a mobile (Android-based) app and how to tackle the development. The role of the different components in app development and being able to choose one over the other depending on the context. Basic knowledge of the Kotlin programming language. Basic knowledge of the technical Android API. Unit testability of mobile applications. Basic knowledge of multi-platform possiblities in the app development world. drawing up a project plan/analysis for mobile development projects.  Course planning See the menu to the left. This course is worth 3.0 ECTS points, hence it will be divided into 12 chunks (weeks) of 1.5h contact moments each. Extra coaching sessions will be planned if required.\nThe course lies in the second semester of the second year and has quite a bit of overlap with other software-related courses happening at the same time, specifically Software Engineering Skills (SES). During the SES lessons, we\u0026rsquo;ll get to know design patterns and unit testing, which will also be applied in this very course.\nEvaluation  No formal exam planned. An android-based project which will have to be defended orally to motivate the taken design and implementation decisions. Open questions will be asked to gauge the knowledge level of the student.  More learning material See the section \u0026ldquo;Extra\u0026rdquo; in the menu or in the links above. Each section will contain a \u0026ldquo;More learning material\u0026rdquo; part at the bottom of each page linking to supplemental bits and pieces for the curious student.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/appdev-course/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]